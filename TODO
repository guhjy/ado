Immediate TODO:
    o) grammar expansion: fully general varlists
        o) factor variable operators ("i.", "c.", "o.", "#"/"##", "ib."/"b."/"X.varname")
        o) :value_label_name
    
    o) next, infrastructural R functions
        o) weeding for each type of node
        o) AST walkers to construct unevaluated calls and expression objects
    
    o) functions for the initial set of commands
    
Later functionality
        o) Loops + Macros
            Suddenly very clear what has to happen here: the containing R environment keeps
            data structures, reads in the program text and then passes it to the parser,
            which does the parse and then as each cmd rule matches, calls back to the weeding +
            transforming + executing code that's written in R.

            That way it works the same for interactive use where the R function reads lines,
            but behaves correctly in batch use. We can also implement macros with this setup.

            Memory management will be...interesting.
        
        o) Many more commands
            o) data management: egen, input, label, etc
            o) graphics
            o) basic stats
        
Debug:
    o) use testthat and travis
    o) write a unit test suite
    o) test, test, test...

Write documentation
    o) man entries, vignettes, examples
    o) document the R expression format the parser emits

Wishlist functionality:
    o) A mechanism for the user to register an R function obeying the
       calling convention as a Stata command
    
    o) time-series operations and grammar

    o) very Stata-like output: unlikely to be worth imitating

