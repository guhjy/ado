D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+

%{
#include <iostream>
#include "rstata.hpp"
#include "ado.tab.hpp"
#define YY_DECL extern "C" int yylex()

using namespace std;

int line_num = 1;
int col_num = 0;

void long_comment();
void short_comment();
void count();
%}

%option noyywrap

%%
                            /* eat comments but track line and column numbers */
"/*"                        { long_comment(); }
\/\/                        { short_comment(); }



                            /* if you write {{{ ... }}}, the ... will be executed as R code */
\{\{\{.*\}\}\}              { count(); yylval.str = strdup(yytext); return EMBEDDED_R; }



                            /* string literals and string data types */
\"\"                        { count(); yylval.str = strdup(yytext); return STRING_MISSING; }
\"(\\.|[^"\\])*\"           { count(); yylval.str = strdup(yytext); return STRING_LITERAL; }

str                         { count(); yylval.str = strdup(yytext); return STRING_TYPE_SPEC; }
str{D}+                     { count(); yylval.str = strdup(yytext); return STRING_TYPE_SPEC; }
strL                        { count(); yylval.str = strdup(yytext); return STRING_TYPE_SPEC; }



                            /* numbers and numeric data types */
\.                          { count(); yylval.str = strdup(yytext); return NUMBER_MISSING; }
\.{L}                       { count(); yylval.str = strdup(yytext); return NUMBER_MISSING; }

[+-]?0[xX]{H}+              { count(); yylval.str = strdup(yytext); return NUMBER; } /* hex */
0{D}+                       { count(); yylval.str = strdup(yytext); return NUMBER; } /* octal */
[+-]?{D}+(\.{D}+)?          { count(); yylval.str = strdup(yytext); return NUMBER; } /* decimal */

{D}+{E}                     { count(); yylval.str = strdup(yytext); return NUMBER; } /* scientific notation */
{D}*"."{D}+({E})?           { count(); yylval.str = strdup(yytext); return NUMBER; }
{D}+"."{D}*({E})?           { count(); yylval.str = strdup(yytext); return NUMBER; }

(?i:byte)                   { count(); yylval.str = strdup(yytext); return BYTE; } /* Stata's numeric data types */
(?i:int)                    { count(); yylval.str = strdup(yytext); return INT; }
(?i:long)                   { count(); yylval.str = strdup(yytext); return LONG; }
(?i:float)                  { count(); yylval.str = strdup(yytext); return FLOAT; }
(?i:double)                 { count(); yylval.str = strdup(yytext); return DOUBLE; }



                            /* format specifiers */
%-?{D}+s                    { count(); yylval.str = strdup(yytext); return STRING_FORMAT; }
%-?0?{D}+\.{D}+[efg]c?      { count(); yylval.str = strdup(yytext); return NUMBER_FORMAT; }
%-?t[Ccdwmqh]{L}*           { count(); yylval.str = strdup(yytext); return DATETIME_FORMAT; }



                            /* logical operators and various single-character tokens */
"&&"                        { count(); yylval.str = strdup(yytext); return AND_OP; }
"&"                         { count(); yylval.str = strdup(yytext); return AND_OP; }
"||"                        { count(); yylval.str = strdup(yytext); return OR_OP; }
"|"                         { count(); yylval.str = strdup(yytext); return OR_OP; }
">="                        { count(); yylval.str = strdup(yytext); return GT_OP; }
"<="                        { count(); yylval.str = strdup(yytext); return LE_OP; }
"=="                        { count(); yylval.str = strdup(yytext); return EQ_OP; }
"!="                        { count(); yylval.str = strdup(yytext); return NE_OP; }

\*                          { count(); yylval.str = strdup(yytext); return '*'; }
\+                          { count(); yylval.str = strdup(yytext); return '+'; }
\/                          { count(); yylval.str = strdup(yytext); return '/'; }
\-                          { count(); yylval.str = strdup(yytext); return '-'; }
%                           { count(); yylval.str = strdup(yytext); return '%'; }

\[                          { count(); yylval.str = strdup(yytext); return '['; }
\]                          { count(); yylval.str = strdup(yytext); return ']'; }
\(                          { count(); yylval.str = strdup(yytext); return '('; }
\)                          { count(); yylval.str = strdup(yytext); return ')'; }
\{                          { count(); yylval.str = strdup(yytext); return '{'; }
\}                          { count(); yylval.str = strdup(yytext); return '}'; }
\"                          { count(); yylval.str = strdup(yytext); return '"'; }
\'                          { count(); yylval.str = strdup(yytext); return '\''; }
=                           { count(); yylval.str = strdup(yytext); return '='; }
,                           { count(); yylval.str = strdup(yytext); return ','; }
:                           { count(); yylval.str = strdup(yytext); return ':'; }



                            /* command verbs */
(?i:exit)                   { count(); yylval.str = strdup(yytext); return EXIT; }
(?i:quit)                   { count(); yylval.str = strdup(yytext); return EXIT; }
(?i:insheet)                { count(); yylval.str = strdup(yytext); return INSHEET; }
(?i:tab)                    { count(); yylval.str = strdup(yytext); return TABLE; }
(?i:tabulate)               { count(); yylval.str = strdup(yytext); return TABLE; }
(?i:outsheet)               { count(); yylval.str = strdup(yytext); return OUTSHEET; }
(?i:sum)                    { count(); yylval.str = strdup(yytext); return SUM; }
(?i:summarize)              { count(); yylval.str = strdup(yytext); return SUM; }
(?i:di)                     { count(); yylval.str = strdup(yytext); return DI; }
(?i:display)                { count(); yylval.str = strdup(yytext); return DI; }
(?i:ls)                     { count(); yylval.str = strdup(yytext); return LS; }
(?i:log)                    { count(); yylval.str = strdup(yytext); return LOG; }
(?i:replace)                { count(); yylval.str = strdup(yytext); return REPLACE; }
(?i:cd)                     { count(); yylval.str = strdup(yytext); return CD; }
(?i:keep)                   { count(); yylval.str = strdup(yytext); return KEEP; }
(?i:merge)                  { count(); yylval.str = strdup(yytext); return MERGE; }
(?i:xtile)                  { count(); yylval.str = strdup(yytext); return XTILE; }
(?i:rename)                 { count(); yylval.str = strdup(yytext); return RENAME; }
(?i:sort)                   { count(); yylval.str = strdup(yytext); return SORT; }
(?i:save)                   { count(); yylval.str = strdup(yytext); return SAVE; }
(?i:drop)                   { count(); yylval.str = strdup(yytext); return DROP; }
(?i:duplicates)             { count(); yylval.str = strdup(yytext); return DUPLICATES; }
(?i:count)                  { count(); yylval.str = strdup(yytext); return COUNT; }
(?i:describe)               { count(); yylval.str = strdup(yytext); return DESCRIBE; }
(?i:generate)               { count(); yylval.str = strdup(yytext); return GEN; }
(?i:order)                  { count(); yylval.str = strdup(yytext); return ORDER; }
(?i:clear)                  { count(); yylval.str = strdup(yytext); return CLEAR; }
(?i:use)                    { count(); yylval.str = strdup(yytext); return USE; }
(?i:set)                    { count(); yylval.str = strdup(yytext); return SET; }
(?i:mlogit)                 { count(); yylval.str = strdup(yytext); return MLOGIT; }
(?i:logit)                  { count(); yylval.str = strdup(yytext); return LOGIT; }
(?i:regress)                { count(); yylval.str = strdup(yytext); return REGRESS; }
(?i:reg)                    { count(); yylval.str = strdup(yytext); return REGRESS; }



                            /* modifiers that can be applied to commands */
(?i:by)                     { count(); yylval.str = strdup(yytext); return BY; }
(?i:bysort)                 { count(); yylval.str = strdup(yytext); return BYSORT; }
(?i:xi)                     { count(); yylval.str = strdup(yytext); return XI; }
(?i:capture)                { count(); yylval.str = strdup(yytext); return CAPTURE; }
(?i:quietly)                { count(); yylval.str = strdup(yytext); return QUIETLY; }
(?i:qui)                    { count(); yylval.str = strdup(yytext); return QUIETLY; }
(?i:noisily)                { count(); yylval.str = strdup(yytext); return NOISILY; }



                            /* post-verb components of commands */
(?i:pweight)                { count(); yylval.str = strdup(yytext); return PWEIGHT; }
(?i:aweight)                { count(); yylval.str = strdup(yytext); return AWEIGHT; }
(?i:fweight)                { count(); yylval.str = strdup(yytext); return FWEIGHT; }
(?i:iweight)                { count(); yylval.str = strdup(yytext); return IWEIGHT; }
(?i:weight)                { count(); yylval.str = strdup(yytext); return WEIGHT; }
(?i:using)                  { count(); yylval.str = strdup(yytext); return USING; }
(?i:in)                     { count(); yylval.str = strdup(yytext); return IN; }
(?i:if)                     { count(); yylval.str = strdup(yytext); return IF; }



                            /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*      { count(); yylval.str = strdup(yytext); return IDENT; }



                            /* ignore whitespace but track line and column numbers */
\n                          { count(); ++line_num; }
[ \t\v\r\f]+                { count(); }
%%

void long_comment()
{
    char c, c1;

loop:
    while ((c = getc(yyin)) != '*' && c != '\0')
    {
        if (c == '\n')
        {
            col_num = 0;
            line_num++;
        }
        else if (c == '\t')
            col_num += 8 - (col_num % 8);
        else
            col_num++;
        
        putchar(c);
    }

    if ((c1 = getc(yyin)) != '/' && c != '\0')
    {
        col_num++; /* for the asterisk that got us here */
        
        unput(c1);
        goto loop;
    }

    if (c != '\0')
        putchar(c1);
}

void short_comment()
{
    char c;
    
    while ((c = getc(yyin)) != '\n' && c != 0)
    {
        if (c == '\t')
            col_num += 8 - (col_num % 8);
        else
            col_num++;
        
        putchar(c);
    }

    col_num = 0;
    line_num++;
}

void count()
{
    int i;

    for (i = 0; yytext[i] != '\0'; i++)
        if (yytext[i] == '\n')
            col_num = 0;
        else if (yytext[i] == '\t')
            col_num += 8 - (col_num % 8);
        else
            col_num++;
}

