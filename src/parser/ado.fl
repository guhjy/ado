%option bison-bridge
%option noyywrap

%{ /* -*- C++ -*- */
#include <cstring>
#include <cerrno>
#include <climits>
#include <cstdlib>
#include <iostream>
#include <string>
#include "RStata.hpp"
#include "ado.tab.hpp"
#include "RStataDriver.hpp"

#ifndef YYSTYPE
#define YYSTYPE yy::RStataParser::semantic_type
#endif

// Functions to eat comments
void long_comment();
void short_comment();

typedef yy::RStataParser::token token;

// Code run each time a pattern is matched
# define YY_USER_ACTION  llocp->columns(yyleng);
%}

D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+
F           [FLfl]
M           (?i:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))
B           [ \t\v\r\f]

%%

%{
// Code run each time yylex is called
llocp->step();
%}


                            /* ignore whitespace but track line and column numbers */
[\n]+                       llocp->lines(yyleng); llocp->step();
{B}+                        llocp->step();

                            /* eat comments */
\/\*                        long_comment();
\/\/                        short_comment();
^\*                         short_comment();



                            /* if you write {{{ ... }}}, the ... will be executed as R code */
\{\{\{.*\}\}\}              {
                                std::string *s = new std::string(yytext);
                                std::string n = s->substr(3, s->length() - 3);
                                delete s;
                                
                                yylval->node = new ExprNode("embedded_r_cmd");
                                yylval->node->addData("text", n);
                                return token::TOK_EMBEDDED_R;
                            }



                            /* string literals and string (or string-ish) data types */
\"\"                        {
                                std::string *s = new std::string;
                                yylval->node = new ExprNode("string_missing");
                                yylval->node->addData("value", *s);
                                return token::TOK_STRING_MISSING;
                            }
\"(\\.|[^"\\])*\"           {
                                std::string *s = new std::string(yytext);
                                std::string n = s->substr(1, s->length() - 1);
                                delete s;

                                yylval->node = new ExprNode("string_literal");
                                yylval->node->addData("value", n);
                                return token::TOK_STRING_LITERAL;
                            }



                                                        /* datetime literals */
{D}{D}{M}{D}+                                           {
                                                            yylval->node = new ExprNode("Datetime");
                                                            yylval->node->addData("date", *(new std::string(yytext)));
                                                            yylval->node->addData("time", *(new std::string("")));
                                                            return token::TOK_DATE;
                                                        }
{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?                        {
                                                            yylval->node = new ExprNode("Datetime");
                                                            yylval->node->addData("date", *(new std::string("")));
                                                            yylval->node->addData("time", *(new std::string(yytext)));
                                                            return token::TOK_TIME;
                                                        }
{D}{D}{M}{D}+[ \t]+{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?     {
                                                            yylval->node = new ExprNode("Datetime");
                                                            yylval->node->addData("datetime", *(new std::string(yytext)));
                                                            return token::TOK_DATETIME;
                                                        }


                            /* format specifiers */
%-?{D}+s                    { yylval->str = new std::string(yytext); return token::TOK_STRING_FORMAT; }
%-?0?{D}+\.{D}+[efg]c?      { yylval->str = new std::string(yytext); return token::TOK_NUMBER_FORMAT; }
%-?t[Ccdwmqh]{L}*           { yylval->str = new std::string(yytext); return token::TOK_DATETIME_FORMAT; }



                            /* Numeric data types */
(?i:byte)                   { yylval->str = new std::string(yytext); return token::TOK_BYTE; }
(?i:int)                    { yylval->str = new std::string(yytext); return token::TOK_INT; }
(?i:long)                   { yylval->str = new std::string(yytext); return token::TOK_LONG; }
(?i:float)                  { yylval->str = new std::string(yytext); return token::TOK_FLOAT; }
(?i:double)                 { yylval->str = new std::string(yytext); return token::TOK_DOUBLE; }



                            /* String data types */
str                         { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
str{D}+                     { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
strL                        { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }



                            /* numbers and numeric data types */
\.                          {
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }
\.{L}                       {
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }

[+-]?0[xX]{H}+              { /* hex */
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }
0{D}+                       { /* octal */
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }
[+-]?{D}+(\.{D}+)?          { /* decimal */
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }

{D}+{E}                     { /* scientific notation */
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }
{D}*"."{D}+({E})?           {
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }
{D}+"."{D}*({E})?           {
                                yylval->node = new ExprNode("Number");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_NUMBER_MISSING;
                            }



                            /* Other keywords */
(?i:using)                  { yylval->str = new std::string(yytext); return token::TOK_USING; }
(?i:if)                     { yylval->str = new std::string(yytext); return token::TOK_IF; }
(?i:in)                     { yylval->str = new std::string(yytext); return token::TOK_IN; }
(1\:1|1\:m|m\:1|m\:m)       { yylval->str = new std::string(yytext); return token::TOK_MERGE_SPEC; }



                            /* logical operators and various single-character tokens */
"&"                         { yylval->str = new std::string(yytext); return token::TOK_AND_OP; }
"|"                         { yylval->str = new std::string(yytext); return token::TOK_OR_OP; }
">"                         { yylval->str = new std::string(yytext); return token::TOK_GT_OP; }
"<"                         { yylval->str = new std::string(yytext); return token::TOK_LT_OP; }
">="                        { yylval->str = new std::string(yytext); return token::TOK_GE_OP; }
"<="                        { yylval->str = new std::string(yytext); return token::TOK_LE_OP; }
"=="                        { yylval->str = new std::string(yytext); return token::TOK_EQ_OP; }
"!="                        { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"~="                        { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"!"                         { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }
"~"                         { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }

\*                          { yylval->str = new std::string(yytext); return token::TOK_STAR; }
\+                          { yylval->str = new std::string(yytext); return token::TOK_PLUS; }
\/                          { yylval->str = new std::string(yytext); return token::TOK_SLASH; }
\-                          { yylval->str = new std::string(yytext); return token::TOK_MINUS; }
\^                          { yylval->str = new std::string(yytext); return token::TOK_CARET; }
=                           { yylval->str = new std::string(yytext); return token::TOK_ASSIGN; }

\[                          { yylval->str = new std::string(yytext); return token::TOK_LBRACKET; }
\]                          { yylval->str = new std::string(yytext); return token::TOK_RBRACKET; }
\(                          { yylval->str = new std::string(yytext); return token::TOK_LPAREN; }
\)                          { yylval->str = new std::string(yytext); return token::TOK_RPAREN; }
\{                          { yylval->str = new std::string(yytext); return token::TOK_LBRACE; }
\}                          { yylval->str = new std::string(yytext); return token::TOK_RBRACE; }
,                           { yylval->str = new std::string(yytext); return token::TOK_COMMA; }
:                           { yylval->str = new std::string(yytext); return token::TOK_COLON; }
;                           { yylval->str = new std::string(yytext); return token::TOK_SEMICOLON; }



                            /* command verbs that have to be hardcoded into the grammar */
(?i:capture)                {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_CAPTURE;
                            }
(?i:quietly)                {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_QUIETLY;
                            }
(?i:qui)                    {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string("quietly")));
                                return token::TOK_QUIETLY;
                            }
(?i:noisily)                {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_NOISILY;
                            }
(?i:merge)                  {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_MERGE;
                            }
(?i:generate)               {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_GENERATE;
                            }
(?i:gen)                    {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_GENERATE;
                            }
(?i:recast)                 {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_RECAST;
                            }
(?i:display)                {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_DISPLAY;
                            }
(?i:format)                 {
                                yylval->node = new ExprNode("GeneralStataCmd");
                                yylval->node->addData("verb", *(new std::string(yytext)));
                                return token::TOK_FORMAT;
                            }



                            /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*      {
                                yylval->node = new ExprNode("Ident");
                                yylval->node->addData("value", *(new std::string(yytext)));
                                return token::TOK_IDENT;
                            }

<<EOF>>                     { yylval->str = new std::string("END"); return token::TOK_END; }

.                           { yylval->str = new std::string(yytext); return token::TOK_ILLEGAL_CHARACTER;  }
%%

void long_comment()
{
    char c, c1;

loop:
    while ((c = getc(yyin)) != '*' && c != '\0')
        putchar(c);

    if ((c1 = getc(yyin)) != '/' && c != '\0')
    {
        unput(c1);
        goto loop;
    }

    if (c != '\0')
        putchar(c1);
}

void short_comment()
{
    char c;
    
    while ((c = getc(yyin)) != '\n' && c != 0)
        putchar(c);
}

// The scanning-related functions of the driver class, which depend on lexer-related objects
void
RStataDriver::scan_begin()
{
    yy_switch_to_buffer(yy_scan_string(text.c_str()));
}

void
RStataDriver::scan_end()
{
    yy_delete_buffer(YY_CURRENT_BUFFER);
}

