%option bison-bridge
%option noyywrap

%{ /* -*- C++ -*- */
#include <cstring>
#include <cerrno>
#include <climits>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <string>
#include "RStata.hpp"
#include "ado.tab.hpp"
#include "RStataDriver.hpp"

#ifndef YYSTYPE
#define YYSTYPE yy::RStataParser::semantic_type
#endif

// Functions to eat comments
void long_comment(yy::RStataParser::location_type* llocp);
void short_comment();

// String utility functions used below
std::vector<std::string> split(const std::string &s, char delim);
std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems);
std::string trim(const std::string& str, const std::string& what = " ");

typedef yy::RStataParser::token token;

// Code run each time a pattern is matched
# define YY_USER_ACTION  llocp->columns(yyleng);
%}

D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+
F           [FLfl]
M           (?i:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))
B           [ \t\v\r\f]

%%

%{
// Code run each time yylex is called
llocp->step();
%}

                                    /* Allow a triple slash at EOL as a line extender */
\/\/\/\n                            { llocp->lines(yyleng); llocp->step();  }



                                    /* eat comments */
\/\*                                { long_comment(llocp); }
\/\/                                { llocp->lines(1); llocp->step(); short_comment(); }
^\*                                 { llocp->lines(1); llocp->step(); short_comment(); }


                                    /* if you write {{{ ... }}}, the ... will be executed as R code */
\{\{\{.*\}\}\}                      {
                                        std::string *s = new std::string(yytext);
                                        
                                        // remove the last three chars
                                        s->pop_back(); s->pop_back(); s->pop_back();
                                        
                                        std::string n = s->substr(3, s->size());
                                        delete s;
                                        
                                        yylval->node = new ExprNode("rstata_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("lang", "R");
                                        return token::TOK_EMBEDDED_CODE;
                                    }
                                    /* similarly, lines that start with "!" or "shell" are sh commands */
^\![^\n]*$                          {
                                        std::string *s = new std::string(yytext);
                                        
                                        std::string n = s->substr(1, s->size());
                                        delete s;
                                        
                                        yylval->node = new ExprNode("rstata_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("lang", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }
^(?i:shell)[^\n]*$                  {
                                        std::string *s = new std::string(yytext);
                                        
                                        std::string n = s->substr(5, s->size());
                                        delete s;
                                        
                                        yylval->node = new ExprNode("rstata_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("type", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }



                                    /* Statement separators; consider more than one in a row to be one */
[\n]+                               { yylval->str = new std::string(yytext); llocp->lines(yyleng); return token::TOK_NEWLINE; }
[;]+                                { yylval->str = new std::string(yytext); return token::TOK_SEMICOLON; }

                                    /* ignore whitespace but track column numbers */
{B}+                                { llocp->step(); }



                                    /* string literals and string (or string-ish) data types */
\"\"                                {
                                        std::string *s = new std::string;
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_string_literal"});
                                        yylval->node->addData("value", *s);
                                        return token::TOK_STRING_MISSING;
                                    }
\"(\\.|[^"\\])*\"                   {
                                        std::string *s = new std::string(yytext);
                                        s->pop_back(); // remove trailing double quote

                                        std::string n = s->substr(1, s->length()); // remove leading double quote
                                        delete s;

                                        yylval->node = new ExprNode({"rstata_literal", "rstata_string_literal"});
                                        yylval->node->addData("value", n);
                                        return token::TOK_STRING_LITERAL;
                                    }



                                                        /* datetime literals */
{D}{D}{M}{D}+                                           {
                                                            yylval->node = new ExprNode({"rstata_literal", "rstata_datetime"});
                                                            
                                                            std::string *s = new std::string(yytext);
                                                            s->append(" 00:00:00");

                                                            yylval->node->addData("value", *s);
                                                            return token::TOK_DATE;
                                                        }
{D}{D}{M}{D}+[ \t]+{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?     {
                                                            yylval->node = new ExprNode({"rstata_literal", "rstata_datetime"});
                                                            
                                                            std::string *s = new std::string(yytext);
                                                            yylval->node->addData("value", *s);
                                                            return token::TOK_DATETIME;
                                                        }


                                    /* format specifiers */
%-?{D}+s                            { yylval->str = new std::string(yytext); return token::TOK_STRING_FORMAT; }
%-?0?{D}+\.{D}+[efg]c?              { yylval->str = new std::string(yytext); return token::TOK_NUMBER_FORMAT; }
%-?t[Ccdwmqh]{L}*                   { yylval->str = new std::string(yytext); return token::TOK_DATETIME_FORMAT; }



                                    /* Numeric data types */
(?i:byte)                           { yylval->str = new std::string(yytext); return token::TOK_BYTE; }
(?i:int)                            { yylval->str = new std::string(yytext); return token::TOK_INT; }
(?i:long)                           { yylval->str = new std::string(yytext); return token::TOK_LONG; }
(?i:float)                          { yylval->str = new std::string(yytext); return token::TOK_FLOAT; }
(?i:double)                         { yylval->str = new std::string(yytext); return token::TOK_DOUBLE; }



                                    /* String data types */
str                                 { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
str{D}+                             { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
strL                                { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }



                                    /* numeric literals in their various formats */
\.                                  {
                                        yylval->node = new ExprNode("rstata_number");

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER_MISSING;
                                    }
\.[a-zA-Z]                          {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER_MISSING;
                                    }

0[xX]{H}+                           { /* hex */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
0{D}+                               { /* octal */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+                                { /* decimal integer */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+\.({D}+)?/[^_A-Za-z_]           { /* decimal float */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+{E}                             { /* scientific notation */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}*"."{D}+({E})?                   { /* scientific notation with fractions, or numbers like ".0239" */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }



                                    /* Other keywords */
(?i:using)                          { yylval->str = new std::string(yytext); return token::TOK_USING; }
(?i:if)                             { yylval->str = new std::string(yytext); return token::TOK_IF; }
(?i:in)                             { yylval->str = new std::string(yytext); return token::TOK_IN; }
(1\:1|1\:m|m\:1|m\:m)               { yylval->str = new std::string(yytext); return token::TOK_MERGE_SPEC; }



                                    /* infix operators and various single-character tokens */
"&"                                 { yylval->str = new std::string(yytext); return token::TOK_AND_OP; }
"|"                                 { yylval->str = new std::string(yytext); return token::TOK_OR_OP; }
">"                                 { yylval->str = new std::string(yytext); return token::TOK_GT_OP; }
"<"                                 { yylval->str = new std::string(yytext); return token::TOK_LT_OP; }
">="                                { yylval->str = new std::string(yytext); return token::TOK_GE_OP; }
"<="                                { yylval->str = new std::string(yytext); return token::TOK_LE_OP; }
"=="                                { yylval->str = new std::string(yytext); return token::TOK_EQ_OP; }
"!="                                { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"~="                                { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"!"                                 { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }
"~"                                 { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }

\*                                  { yylval->str = new std::string(yytext); return token::TOK_STAR; }
\+                                  { yylval->str = new std::string(yytext); return token::TOK_PLUS; }
\/                                  { yylval->str = new std::string(yytext); return token::TOK_SLASH; }
\-                                  { yylval->str = new std::string(yytext); return token::TOK_MINUS; }
\^                                  { yylval->str = new std::string(yytext); return token::TOK_CARET; }
=                                   { yylval->str = new std::string(yytext); return token::TOK_ASSIGN; }

\[                                  { yylval->str = new std::string(yytext); return token::TOK_LBRACKET; }
\]                                  { yylval->str = new std::string(yytext); return token::TOK_RBRACKET; }
\(                                  { yylval->str = new std::string(yytext); return token::TOK_LPAREN; }
\)                                  { yylval->str = new std::string(yytext); return token::TOK_RPAREN; }
\{                                  { yylval->str = new std::string(yytext); return token::TOK_LBRACE; }
\}                                  { yylval->str = new std::string(yytext); return token::TOK_RBRACE; }
,                                   { yylval->str = new std::string(yytext); return token::TOK_COMMA; }
:                                   { yylval->str = new std::string(yytext); return token::TOK_COLON; }

                                    /* Factor variable operators and level-restricted virtual variables */
"c."                                {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_continuous_expression"});
                                        yylval->node->addData("verb", "c.");

                                        return token::TOK_CONT_OPERATOR;
                                    }
"i."                                {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        return token::TOK_IND_OPERATOR;
                                    }
                                    
i?"bn."                             {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "n");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(freq)."                        {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "freq");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(last)."                        {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "last");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(first)."                       {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "first");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b"{D}+"."                        {
                                        std::string *s = new std::string(yytext);
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        
                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(#"{D}+")."                     {
                                        std::string *s = new std::string(yytext);
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(4, s->length() - 2));
                                        else
                                          yylval->node->addData("level", s->substr(3, s->length() - 2));

                                        delete s;

                                        return token::TOK_BASE_OPERATOR;
                                    }
                                    
i?{D}+"."                          {
                                        std::string *s = new std::string(yytext);
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");
                                        yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("{D}+(\ +{D}+)*")."              {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() - 2), ' ');
                                        delete s;
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("\ *{D}+\ *\/{D}+\ *")."         {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() -2), ' ');
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }
                            
i?"o"{D}+"."                        {
                                        std::string *s = new std::string(yytext);
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_OMIT_OPERATOR;
                                    }
i?"o("{D}+(\ +{D}+)*")."            {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");
                                        
                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), ' ');
                                        else
                                            x = split(s->substr(2, s->length() -2), ' ');

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        delete s;
                                        
                                        return token::TOK_IND_OPERATOR;
                                    }
i?"o("\ *{D}+\ *\/{D}+\ *")."       {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;
                                        
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");
                                        
                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), ' ');
                                        else
                                            x = split(s->substr(2, s->length() -2), ' ');

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }

"##"                                { yylval->str = new std::string(yytext); return token::TOK_FACT_CROSS; }
"#"                                 { yylval->str = new std::string(yytext); return token::TOK_CROSS; }



                                    /* command verbs that have to be hardcoded into the grammar */
(?i:by)                             {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_general_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_BY;
                                    }
(?i:xi)                             {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_general_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_XI;
                                    }
(?i:capture)                        {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_CAPTURE;
                                    }
(?i:cap)                            {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", "capture");
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_CAPTURE;
                                    }
(?i:quietly)                        {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_QUIETLY;
                                    }
(?i:qui)                            {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", "quietly");
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_QUIETLY;
                                    }
(?i:noisily)                        {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));
                                        
                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_NOISILY;
                                    }
                                    
                                    /* Non-prefix special commands */
(?i:merge)                          {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        
                                        return token::TOK_MERGE;
                                    }
(?i:display)                        {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        
                                        return token::TOK_DISPLAY;
                                    }
(?i:format)                         {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        
                                        return token::TOK_FORMAT;
                                    }



                                    /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*              {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_IDENT;
                                    }

<<EOF>>                             { return token::TOK_END; }

.                                   { yylval->str = new std::string(yytext); return token::TOK_ILLEGAL_CHARACTER;  }

%%

// Functions to eat comments
void long_comment(yy::RStataParser::location_type* llocp)
{
    char c, c1;

loop:
    while ((c = getc(yyin)) != '*' && c != '\0')
    {
        if(c == '\n')
        {
            llocp->lines(1);
            llocp->step();
        }

        putchar(c);
    }

    if(c != '\0')
    {
        llocp->step(); // for the '*'

        if( (c1 = getc(yyin)) != '/')
        {
            unput(c1);
            goto loop;
        }

        llocp->step(); // for the '/'
        putchar(c1);
    }
}

void short_comment()
{
    char c;
    
    while ((c = getc(yyin)) != '\n' && c != 0)
        putchar(c);
}

// String utility functions used above
std::vector<std::string> &
split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

std::vector<std::string>
split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

std::string
trim(const std::string& str, const std::string& what)
{
    size_t start = str.find_first_not_of(what);
    size_t end = str.find_last_not_of(what);
    size_t len = end - start + 1;
    
    if (start == std::string::npos)
        return "";

    return str.substr(start, len);
}

// The scanning-related functions of the driver class, which depend on lexer-related objects
void
RStataDriver::scan_begin()
{
    yy_switch_to_buffer(yy_scan_string(text.c_str()));
}

void
RStataDriver::scan_end()
{
    yy_delete_buffer(YY_CURRENT_BUFFER);
}

