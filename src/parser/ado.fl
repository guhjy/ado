%option stack
%option bison-bridge
%option noyywrap

%{ /* -*- C++ -*- */
#include <cstring>
#include <cerrno>
#include <climits>
#include <cstdlib>
#include <cstdio>

#include <stack>
#include <vector>
#include <iostream>
#include <sstream>
#include <string>

#include "RStata.hpp"
#include "ado.tab.hpp"
#include "RStataDriver.hpp"

#ifndef YYSTYPE
#define YYSTYPE yy::RStataParser::semantic_type
#endif

// String utility functions used and defined below
std::vector<std::string> split(const std::string &s, char delim);
std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems);
std::string trim(const std::string& str, const std::string& what = " ");

typedef yy::RStataParser::token token;

// Because of macro expansion, we can't use flex's buffer stack. (The
// reason being that if each macro and the main source were a buffer,
// tokens would have to be able to cross buffer boundaries.) So we'll
// redefine YY_INPUT instead.
// 
// Read a character at a time from a) the macro_buf buffer if it has
// length greater than 0, or b) yyin if not. If we read a character from
// macro_buf, erase() that character.
// FIXME does it have to be a character at a time?
#define YY_INPUT(buf,result,max_size) \
    {\
        // FIXME \
    }

// Code run each time a pattern is matched
#define YY_USER_ACTION  { llocp->columns(yyleng); }
%}

%x LONG_COMMENT
%x SHORT_COMMENT

%x LOCAL_MACRO
%x GLOBAL_MACRO
%x CDQUOTE

%x EMBED
%x STRING

D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+
F           [FLfl]
M           (?i:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))
B           [ \t\v\r\f]

%%

%{
// Code run each time yylex is called
llocp->step();

// Buffers and stacks for state machines
std::string embed_buf;
std::string cdquote_buf;
std::string string_buf;

std::stack<std::vector<std::string>> macro_stack;
std::string macro_buf;
%}
                                    /* if you write {{{ ... }}}, the ... will be executed as R code */
<INITIAL>"{{{"                      {
                                        embed_buf.clear();
                                        yy_push_state(EMBED);
                                    }
<EMBED>{
    "}}}"                           {
                                        yy_pop_state();

                                        ExprNode *node = new ExprNode("rstata_embedded_code");
                                        node->addData("value", std::string(embed_buf));
                                        node->addData("lang", "R");

                                        yylval->node = node;
                                        return token::TOK_EMBEDDED_CODE;
                                    }
    
    [\n]+                           {
                                        llocp->lines(yyleng);
                                        embed_buf += std::string(yytext);
                                    }
    \}[^\}]                         { embed_buf += std::string(yytext); }
    \}\}[^\}]                       { embed_buf += std::string(yytext); }
    [^\}\n]+                        { embed_buf += std::string(yytext); }

    <<EOF>>                         {
                                        embed_buf.clear();
                                        yy_pop_state();
                                        
                                        driver.error(*llocp, "Unclosed embed block");
                                        yyterminate();
                                    }
}



                                    /* Macros, local and global */
<INITIAL>\`                         {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO);
                                    }
<INITIAL>\$                         {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GLOBAL_MACRO);
                                    }

<LOCAL_MACRO>{
    \`                              {
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO);
                                    }
    \$                              {
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GLOBAL_MACRO);
                                    }

    \n                              {
                                        llocp->lines(1);
                                        
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state();
                                        } while(yy_top_state() != INITIAL);
                                        
                                        driver.error(*llocp, "Unclosed local macro");
                                        yyterminate();
                                    }

    \'                              {
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;

                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        combined = std::string("_") + combined; // local macros start with a "_"
                                        
                                        replacement = driver.get_macro_value(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state();
                                        } else
                                        {
                                            yy_pop_state();

                                            switch(yy_top_state())
                                            {
                                                case CDQUOTE:
                                                    cdquote_buf += replacement;
                                                    break;
                                                case STRING:
                                                    string_buf += replacement;
                                                    break;
                                                case INITIAL:
                                                    // don't try to scan from the empty string an undefined
                                                    // macro returns as its replacement text
                                                    if(replacement.length() > 0)
                                                        macro_buf = std::string(replacement);
                                                    break;
                                                default:
                                                    driver.error(*llocp, "Macro in impossible location");
                                                    yyterminate();
                                            }
                                        }
                                    }
    
    [^\`\'\n]+                      {
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }
    
    <<EOF>>                         {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state();
                                        } while(yy_top_state() != INITIAL);
                                        
                                        driver.error(*llocp, "Unclosed local macro");
                                        yyterminate();
                                    }
}

<GLOBAL_MACRO>{
    \`                              {
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(LOCAL_MACRO);
                                    }
    \$                              {
                                        // create and push a stack frame
                                        std::vector<std::string> frame;
                                        macro_stack.push(frame);

                                        yy_push_state(GLOBAL_MACRO);
                                    }

                                    /* The delimiter characters that mean we're at the end of the macro */
    [{B}|\n|\;]+                    {
                                        std::vector<std::string> frame = macro_stack.top();
                                        std::string combined, replacement;

                                        macro_stack.pop();
                                        
                                        for(size_t i = 0; i < frame.size(); i++)
                                            combined += frame[i];
                                        
                                        replacement = driver.get_macro_value(combined);

                                        if(!macro_stack.empty())
                                        {
                                            std::vector<std::string> prev = macro_stack.top();
                                            macro_stack.pop();

                                            prev.push_back(replacement);
                                            macro_stack.push(prev);
                                            
                                            yy_pop_state();
                                        } else
                                        {
                                            yy_pop_state();

                                            switch(yy_top_state())
                                            {
                                                case CDQUOTE:
                                                    cdquote_buf += replacement;
                                                    break;
                                                case STRING:
                                                    string_buf += replacement;
                                                    break;
                                                case INITIAL:
                                                    // don't try to scan from the empty string an undefined
                                                    // macro returns as its replacement text
                                                    if(replacement.length() > 0)
                                                        macro_buf = std::string(replacement);
                                                    break;
                                                default:
                                                    driver.error(*llocp, "Macro in impossible location");
                                                    yyterminate();
                                            }
                                        }
                                    }

                                    /* The ${...} syntax. These are balanced delimiters, but they can't be nested. */
    \{[^\{\}\n\$\`]+\}              {
                                        // push yytext to the back of the current frame, removing the "{" and "}"
                                        std::string s = std::string(yytext);
                                        s.erase(s.begin(), 1);
                                        s.pop_back();
                                        
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(s);
                                        macro_stack.push(frame);
                                    }

                                    /* A global macro name that doesn't need to be disambiguated with braces */
    ({L}|{D})+                      {
                                        // push yytext to the back of the current frame
                                        std::vector<std::string> frame = macro_stack.top();
                                        macro_stack.pop();

                                        frame.push_back(std::string(yytext));
                                        macro_stack.push(frame);
                                    }
   
                                    /* Any other character is an error. */
    .                               {
                                        while(!macro_stack.empty())
                                            macro_stack.pop();
                                        
                                        do {
                                            yy_pop_state();
                                        } while(yy_top_state() != INITIAL);
                                        
                                        driver.error(*llocp, "Invalid global macro");
                                        yyterminate();
                                    }
}



                                    /* Eat long comments */
                                    /* FIXME */
<INITIAL>"/*"                       { yy_push_state(LONG_COMMENT); }
<LONG_COMMENT>{
    "/*"                            { yy_push_state(LONG_COMMENT); }
    "/"+[^\n]                       { /* skip "/" if not followed by a newline */ }
    "/"+[^\*]                       { /* skip "/" if not followed by "*" */ }
    [^/\*\n]*                       { /* skip anything but "*", "/" and newline */ }
    "*"+[^\*/\n]*                   { /* skip "*"s not followed by a "/" or newline */ }
    [\n]+                           { llocp->lines(yyleng); }
    "*"+"/"                         { yy_pop_state(); }

    <<EOF>>                         {
                                        yy_pop_state();
                                        driver.error(*llocp, "Unclosed comment");
                                        yyterminate();
                                    }
}


                                    /* Allow a triple slash at EOL as a line extender */
\/\/\/\n                            { llocp->lines(yyleng); llocp->step(); }



                                    /* Eat short comments */
<INITIAL>"//"                       { yy_push_state(SHORT_COMMENT); }
<INITIAL>^\*                        { yy_push_state(SHORT_COMMENT); }
<SHORT_COMMENT>{
    [^\n]*                          { /* eat anything but a newline */ }
    \n                              {
                                         yy_pop_state();
                                         llocp->lines(1);
                                         return token::TOK_NEWLINE;
                                    }
}



                                    /* similarly, lines that start with "!" or "shell" are sh commands */
^\![^\n]*$                          {
                                        std::string *s = new std::string(yytext);

                                        std::string n = s->substr(1, s->size());
                                        delete s;

                                        yylval->node = new ExprNode("rstata_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("lang", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }
^shell[^\n]*$                       {
                                        std::string *s = new std::string(yytext);

                                        std::string n = s->substr(5, s->size());
                                        delete s;

                                        yylval->node = new ExprNode("rstata_embedded_code");
                                        yylval->node->addData("value", n);
                                        yylval->node->addData("type", "shell");
                                        return token::TOK_EMBEDDED_CODE;
                                    }



                                    /* Statement separators; consider more than one in a row to be one */
[\n]+                               {
                                        yylval->str = new std::string(yytext);
                                        llocp->lines(yyleng);
                                        return token::TOK_NEWLINE;
                                    }
[;]+                                {
                                        yylval->str = new std::string(yytext);
                                        return token::TOK_SEMICOLON;
                                    }

                                    /* ignore whitespace but track column numbers */
{B}+                                { llocp->step(); }


                                    /* FIXME */
<INITIAL>\`\"                       { cdquote_buf.clear(); yy_push_state(CDQUOTE); }
<CDQUOTE>{
    \"\'                            {
                                        /* Saw the matching close quote - all done */
                                        std::string *s = new std::string(cdquote_buf);
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_string_literal"});
                                        yylval->node->addData("value", *s);

                                        yy_pop_state();
                                        return token::TOK_STRING_LITERAL;
                                    }

                                    /* Unlike in Stata, strings can continue over multiple lines */
    [\n]+                           { llocp->lines(yyleng); cdquote_buf += std::string(yytext); }

    \\\$                            { cdquote_buf += '$'; }
    \\\`                            { cdquote_buf += '`'; }
    \\n                             { cdquote_buf += '\n'; }
    \\t                             { cdquote_buf += '\t'; }
    \\r                             { cdquote_buf += '\r'; }
    \\b                             { cdquote_buf += '\b'; }
    \\f                             { cdquote_buf += '\f'; }
    \\.                             { cdquote_buf += yytext[1]; }
    \\                              { cdquote_buf += '\\'; }

    [^\\\n\`\$]+                    { cdquote_buf += std::string(yytext); }

                                    /* Code run on seeing macro terminators will check if the new top state is CDQUOTE
                                       and append the macro replacement text to cdquote_buf if so. */
    \`                              { yy_push_state(LOCAL_MACRO); }
    \$                              { yy_push_state(GLOBAL_MACRO); }

    <<EOF>>                         {
                                        cdquote_buf.clear();
                                        yy_pop_state();

                                        driver.error(*llocp, "Unclosed compound double quote");
                                        yyterminate();
                                    }
}

<INITIAL>\"                         { string_buf.clear(); yy_push_state(STRING); }
<STRING>{
    \"                              {
                                        /* Saw a close quote - all done */
                                        std::string *s = new std::string(string_buf);
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_string_literal"});
                                        yylval->node->addData("value", *s);

                                        yy_pop_state();
                                        return token::TOK_STRING_LITERAL;
                                    }

                                    /* Unlike in Stata, strings can continue over multiple lines */
    [\n]+                           { llocp->lines(yyleng); string_buf += std::string(yytext); }

    \\\"                            { string_buf += '"'; }
    \\\`                            { string_buf += '`'; }
    \\\$                            { string_buf += '$'; }
    \\n                             { string_buf += '\n'; }
    \\t                             { string_buf += '\t'; }
    \\r                             { string_buf += '\r'; }
    \\b                             { string_buf += '\b'; }
    \\f                             { string_buf += '\f'; }
    \\.                             { string_buf += yytext[1]; }
    \\                              { string_buf += '\\'; }

                                    /* Code run on seeing macro terminators will check if the new top state is STRING
                                       and append the macro replacement text to string_buf if so. */
    \`                              { yy_push_state(LOCAL_MACRO); }
    \$                              { yy_push_state(GLOBAL_MACRO); }

    [^\\\n\"\`\$]+                  { string_buf += std::string(yytext); }

    <<EOF>>                         {
                                        string_buf.clear();
                                        yy_pop_state();

                                        driver.error(*llocp, "Unclosed string literal");
                                        yyterminate();
                                    }
}



                                                        /* datetime literals */
{D}{D}{M}{D}+                                           {
                                                            yylval->node = new ExprNode({"rstata_literal", "rstata_datetime"});

                                                            std::string *s = new std::string(yytext);
                                                            s->append(" 00:00:00");

                                                            yylval->node->addData("value", *s);
                                                            return token::TOK_DATE;
                                                        }
{D}{D}{M}{D}+[ \t]+{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?     {
                                                            yylval->node = new ExprNode({"rstata_literal", "rstata_datetime"});

                                                            std::string *s = new std::string(yytext);
                                                            yylval->node->addData("value", *s);
                                                            return token::TOK_DATETIME;
                                                        }


                                    /* format specifiers */
%-?{D}+s                            { yylval->str = new std::string(yytext); return token::TOK_STRING_FORMAT; }
%-?0?{D}+\.{D}+[efg]c?              { yylval->str = new std::string(yytext); return token::TOK_NUMBER_FORMAT; }
%-?t[Ccdwmqh]{L}*                   { yylval->str = new std::string(yytext); return token::TOK_DATETIME_FORMAT; }



                                    /* Numeric data types */
byte                                { yylval->str = new std::string(yytext); return token::TOK_BYTE; }
int                                 { yylval->str = new std::string(yytext); return token::TOK_INT; }
long                                { yylval->str = new std::string(yytext); return token::TOK_LONG; }
float                               { yylval->str = new std::string(yytext); return token::TOK_FLOAT; }
double                              { yylval->str = new std::string(yytext); return token::TOK_DOUBLE; }



                                    /* String data types */
str                                 { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
str{D}+                             { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }
strL                                { yylval->str = new std::string(yytext); return token::TOK_STRING_TYPE_SPEC; }



                                    /* numeric literals in their various formats */
\.                                  {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER_MISSING;
                                    }
0[xX]{H}+                           { /* hex */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
0{D}+                               { /* octal */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+                                { /* decimal integer */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+\.({D}+)?/[^_A-Za-z_]           { /* decimal float */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}+{E}                             { /* scientific notation */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }
{D}*"."{D}+({E})?                   { /* scientific notation with fractions, or numbers like ".0239" */
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_number"});

                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_NUMBER;
                                    }



                                    /* Other keywords */
using                               { yylval->str = new std::string(yytext); return token::TOK_USING; }
if                                  { yylval->str = new std::string(yytext); return token::TOK_IF; }
in                                  { yylval->str = new std::string(yytext); return token::TOK_IN; }
(1\:1|1\:m|m\:1|m\:m)               { yylval->str = new std::string(yytext); return token::TOK_MERGE_SPEC; }



                                    /* Weight-clause specifiers (this is a hack) */
"["{B}*(a|p|i|f)weight{B}*"="       {
                                        ExprNode *clause = new ExprNode("rstata_weight_clause");
                                        ExprNode *kind = new ExprNode({"rstata_literal", "rstata_ident"});
                                        std::string *s = new std::string(yytext);

                                        // remove the first and last characters of the string
                                        s->pop_back();
                                        std::string n0 = s->substr(1, s->size());
                                        delete s;

                                        kind->addData("value", trim(n0));
                                        clause->appendChild("left", kind);

                                        yylval->node = clause;
                                        return token::TOK_WEIGHT_SPEC;
                                    }



                                    /* infix operators and various single-character tokens */
"&"                                 { yylval->str = new std::string(yytext); return token::TOK_AND_OP; }
"|"                                 { yylval->str = new std::string(yytext); return token::TOK_OR_OP; }
">"                                 { yylval->str = new std::string(yytext); return token::TOK_GT_OP; }
"<"                                 { yylval->str = new std::string(yytext); return token::TOK_LT_OP; }
">="                                { yylval->str = new std::string(yytext); return token::TOK_GE_OP; }
"<="                                { yylval->str = new std::string(yytext); return token::TOK_LE_OP; }
"=="                                { yylval->str = new std::string(yytext); return token::TOK_EQ_OP; }
"!="                                { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"~="                                { yylval->str = new std::string(yytext); return token::TOK_NE_OP; }
"!"                                 { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }
"~"                                 { yylval->str = new std::string(yytext); return token::TOK_NEG_OP; }

\*                                  { yylval->str = new std::string(yytext); return token::TOK_STAR; }
\+                                  { yylval->str = new std::string(yytext); return token::TOK_PLUS; }
\/                                  { yylval->str = new std::string(yytext); return token::TOK_SLASH; }
\-                                  { yylval->str = new std::string(yytext); return token::TOK_MINUS; }
\^                                  { yylval->str = new std::string(yytext); return token::TOK_CARET; }
=                                   { yylval->str = new std::string(yytext); return token::TOK_ASSIGN; }

\[                                  { yylval->str = new std::string(yytext); return token::TOK_LBRACKET; }
\]                                  { yylval->str = new std::string(yytext); return token::TOK_RBRACKET; }
\(                                  { yylval->str = new std::string(yytext); return token::TOK_LPAREN; }
\)                                  { yylval->str = new std::string(yytext); return token::TOK_RPAREN; }
\{                                  { yylval->str = new std::string(yytext); return token::TOK_LBRACE; }
\}                                  { yylval->str = new std::string(yytext); return token::TOK_RBRACE; }
,                                   { yylval->str = new std::string(yytext); return token::TOK_COMMA; }
:                                   { yylval->str = new std::string(yytext); return token::TOK_COLON; }

                                    /* Factor variable operators and level-restricted virtual variables */
"c."                                {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_continuous_expression"});
                                        yylval->node->addData("verb", "c.");

                                        return token::TOK_CONT_OPERATOR;
                                    }
"i."                                {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        return token::TOK_IND_OPERATOR;
                                    }

i?"bn."                             {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "n");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(freq)."                        {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "freq");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(last)."                        {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "last");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(first)."                       {
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");
                                        yylval->node->addData("level", "first");

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b"{D}+"."                        {
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_BASE_OPERATOR;
                                    }
i?"b(#"{D}+")."                     {
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_baseline_expression"});
                                        yylval->node->addData("verb", "ib.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(4, s->length() - 2));
                                        else
                                          yylval->node->addData("level", s->substr(3, s->length() - 2));

                                        delete s;

                                        return token::TOK_BASE_OPERATOR;
                                    }

i?{D}+"."                          {
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");
                                        yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("{D}+(\ +{D}+)*")."              {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() - 2), ' ');
                                        delete s;

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        return token::TOK_IND_OPERATOR;
                                    }
"i("\ *{D}+\ *\/{D}+\ *")."         {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x = split(s->substr(2, s->length() -2), ' ');
                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_indicator_expression"});
                                        yylval->node->addData("verb", "i.");

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }

i?"o"{D}+"."                        {
                                        std::string *s = new std::string(yytext);

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                          yylval->node->addData("level", s->substr(2, s->length() - 1));
                                        else
                                          yylval->node->addData("level", s->substr(1, s->length() - 1));

                                        delete s;

                                        return token::TOK_OMIT_OPERATOR;
                                    }
i?"o("{D}+(\ +{D}+)*")."            {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), ' ');
                                        else
                                            x = split(s->substr(2, s->length() -2), ' ');

                                        for(auto elem : x)
                                        {
                                            if(!elem.empty())
                                                yylval->node->addData("level" + elem, elem); // hacky, but oh well
                                        }

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }
i?"o("\ *{D}+\ *\/{D}+\ *")."       {
                                        std::string *s = new std::string(yytext);
                                        std::vector<std::string> x;

                                        yylval->node = new ExprNode({"rstata_expression", "rstata_factor_expression", "rstata_omit_expression"});
                                        yylval->node->addData("verb", "o.");

                                        if(s->at(0) == 'i')
                                            x = split(s->substr(3, s->length() -2), ' ');
                                        else
                                            x = split(s->substr(2, s->length() -2), ' ');

                                        yylval->node->addData("levelstart", trim(x[0]));
                                        yylval->node->addData("levelend", trim(x[1]));

                                        delete s;

                                        return token::TOK_IND_OPERATOR;
                                    }

"##"                                { yylval->str = new std::string(yytext); return token::TOK_FACT_CROSS; }
"#"                                 { yylval->str = new std::string(yytext); return token::TOK_CROSS; }



                                    /* command verbs that have to be hardcoded into the grammar */
by                                  {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_general_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_BY;
                                    }
bysort                              {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_general_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_BYSORT;
                                    }
xi                                  {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_general_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_XI;
                                    }
capture                             {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_CAPTURE;
                                    }
cap                                 {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", "capture");

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_CAPTURE;
                                    }
quietly                             {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_QUIETLY;
                                    }
qui                                 {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", "quietly");

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_QUIETLY;
                                    }
noisily                             {
                                        ExprNode *verb = new ExprNode({"rstata_literal", "rstata_ident"});
                                        verb->addData("value", *(new std::string(yytext)));

                                        yylval->node = new ExprNode({"rstata_cmd","rstata_modifier_cmd"});
                                        yylval->node->appendChild("verb", verb);
                                        return token::TOK_NOISILY;
                                    }

                                    /* Non-prefix special commands */
merge                               {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));

                                        return token::TOK_MERGE;
                                    }
display                             {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));

                                        return token::TOK_DISPLAY;
                                    }
disp                                {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));

                                        return token::TOK_DISPLAY;
                                    }
di                                  {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));

                                        return token::TOK_DISPLAY;
                                    }
format                              {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));

                                        return token::TOK_FORMAT;
                                    }



                                    /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*              {
                                        yylval->node = new ExprNode({"rstata_literal", "rstata_ident"});
                                        yylval->node->addData("value", *(new std::string(yytext)));
                                        return token::TOK_IDENT;
                                    }

.                                   { driver.error(*llocp, "Illegal character"); yyterminate(); }

<<EOF>>                             { return token::TOK_END; }

%%

// String utility functions used above
std::vector<std::string> &
split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

std::vector<std::string>
split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

std::string
trim(const std::string& str, const std::string& what)
{
    size_t start = str.find_first_not_of(what);
    size_t end = str.find_last_not_of(what);
    size_t len = end - start + 1;

    if (start == std::string::npos)
        return "";

    return str.substr(start, len);
}

// The scanning-related functions of the driver class, which depend on lexer objects
void
RStataDriver::scan_begin()
{
    yy_switch_to_buffer(yy_scan_string(text.c_str()));
}

void
RStataDriver::scan_end()
{
    yy_delete_buffer(YY_CURRENT_BUFFER);
}

