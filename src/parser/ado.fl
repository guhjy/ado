%{ /* -*- C++ -*- */
#include <cstring>
#include <cerrno>
#include <climits>
#include <cstdlib>
#include <iostream>
#include <string>
#include "RStata.hpp"
#include "ado.tab.hpp"
#include "RStataDriver.hpp"

#define yyterminate() raise_condition("Terminated", "error")

// Functions to eat comments
void long_comment();
void short_comment();

static yy::location loc;
%}

%option noyywrap debug

D           [0-9]
L           [a-zA-Z_]
H           [a-fA-F0-9]
E           [Ee][+-]?{D}+
F           [FLfl]
M           (?i:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))
B           [ \t\v\r\f]

%{
    // Code run each time a pattern is matched
    # define YY_USER_ACTION  loc.columns(yyleng);
%}

%%

%{
    // Code run each time yylex is called
    loc.step();
%}

                            /* ignore whitespace but track line and column numbers */
[\n]+                       loc.lines(yyleng); loc.step();
{B}+                        loc.step();

                            /* eat comments */
"/*"                        long_comment();
\/\/                        short_comment();
^\*                         short_comment();



                            /* if you write {{{ ... }}}, the ... will be executed as R code */
\{\{\{.*\}\}\}              {
                                char *s;
                                
                                /* chop off the first and last three characters of yytext,
                                   which are the {{{ and }}} that begin and end this command */
                                s = strdup(yytext);
                                s[strlen(s) - 3] = '\0';
                                s += 3;
                                
                                return yy::RStataParser::make_EMBEDDED_R(new EmbeddedRCmd(std::string(s)), loc);
                            }



                            /* string literals and string (or string-ish) data types */
\"\"                        return yy::RStataParser::make_STRING_MISSING(new StringExprNode(""), loc);
\"(\\.|[^"\\])*\"           return yy::RStataParser::make_STRING_LITERAL(new StringExprNode(yytext), loc);



                                                        /* datetime literals */
{D}{D}{M}{D}+                                           return yy::RStataParser::make_DATE(new DatetimeExprNode(std::string(yytext), std::string("")), loc);
{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?                        return yy::RStataParser::make_TIME(new DatetimeExprNode(std::string(""), std::string(yytext)), loc);
{D}{D}{M}{D}+[ \t]+{D}{D}:{D}{D}(:{D}{D}(\.{D}+)?)?     return yy::RStataParser::make_DATETIME(new DatetimeExprNode(yytext), loc);



                            /* numbers and numeric data types */
\.                          return yy::RStataParser::make_NUMBER_MISSING(new NumberExprNode(""), loc);
\.{L}                       return yy::RStataParser::make_NUMBER_MISSING(new NumberExprNode(""), loc);

[+-]?0[xX]{H}+              return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc); /* hex */
0{D}+                       return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc); /* octal */
[+-]?{D}+(\.{D}+)?          return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc); /* decimal */

{D}+{E}                     return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc); /* scientific notation */
{D}*"."{D}+({E})?           return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc);
{D}+"."{D}*({E})?           return yy::RStataParser::make_NUMBER(new NumberExprNode(yytext), loc);



                            /* Other keywords */
(?i:using)                  return yy::RStataParser::make_USING(yytext, loc);
(?i:if)                     return yy::RStataParser::make_IF(yytext, loc);
(?i:in)                     return yy::RStataParser::make_IN(yytext, loc);
(1\:1|1\:m|m\:1|m\:m)       return yy::RStataParser::make_MERGE_SPEC(yytext, loc);


                            /* logical operators and various single-character tokens */
"&"                         return yy::RStataParser::make_AND_OP(yytext, loc);
"|"                         return yy::RStataParser::make_OR_OP(yytext, loc);
">"                         return yy::RStataParser::make_GT_OP(yytext, loc);
"<"                         return yy::RStataParser::make_LT_OP(yytext, loc);
">="                        return yy::RStataParser::make_GE_OP(yytext, loc);
"<="                        return yy::RStataParser::make_LE_OP(yytext, loc);
"=="                        return yy::RStataParser::make_EQ_OP(yytext, loc);
"!="                        return yy::RStataParser::make_NE_OP(yytext, loc);
"~="                        return yy::RStataParser::make_NE_OP(yytext, loc);
"!"                         return yy::RStataParser::make_NEG_OP(yytext, loc);
"~"                         return yy::RStataParser::make_NEG_OP("!", loc);

\*                          return yy::RStataParser::make_STAR(yytext, loc);
\+                          return yy::RStataParser::make_PLUS(yytext, loc);
\/                          return yy::RStataParser::make_SLASH(yytext, loc);
\-                          return yy::RStataParser::make_MINUS(yytext, loc);
\^                          return yy::RStataParser::make_CARET(yytext, loc);
=                           return yy::RStataParser::make_ASSIGN(yytext, loc);

\[                          return yy::RStataParser::make_LBRACKET(yytext, loc);
\]                          return yy::RStataParser::make_RBRACKET(yytext, loc);
\(                          return yy::RStataParser::make_LPAREN(yytext, loc);
\)                          return yy::RStataParser::make_RPAREN(yytext, loc);
\{                          return yy::RStataParser::make_LBRACE(yytext, loc);
\}                          return yy::RStataParser::make_RBRACE(yytext, loc);
\"                          return yy::RStataParser::make_DQUOTE(yytext, loc);
\'                          return yy::RStataParser::make_SQUOTE(yytext, loc);
,                           return yy::RStataParser::make_COMMA(yytext, loc);
:                           return yy::RStataParser::make_COLON(yytext, loc);



                            /* command verbs that have to be hardcoded into the grammar */
(?i:capture)                return yy::RStataParser::make_CAPTURE(MakeGeneralStataCmd(yytext).create(), loc);
(?i:quietly)                return yy::RStataParser::make_QUIETLY(MakeGeneralStataCmd(yytext).create(), loc);
(?i:qui)                    return yy::RStataParser::make_QUIETLY(MakeGeneralStataCmd("quietly").create(), loc);
(?i:noisily)                return yy::RStataParser::make_NOISILY(MakeGeneralStataCmd(yytext).create(), loc);
(?i:merge)                  return yy::RStataParser::make_MERGE(MakeGeneralStataCmd(yytext).create(), loc);



                            /* all non-keyword identifiers */
[_A-Za-z][A-Za-z0-9_]*      return yy::RStataParser::make_IDENT(new IdentExprNode(yytext), loc);

%%

void long_comment()
{
    char c, c1;

loop:
    while ((c = getc(yyin)) != '*' && c != '\0')
        putchar(c);

    if ((c1 = getc(yyin)) != '/' && c != '\0')
    {
        unput(c1);
        goto loop;
    }

    if (c != '\0')
        putchar(c1);
}

void short_comment()
{
    char c;
    
    while ((c = getc(yyin)) != '\n' && c != 0)
        putchar(c);
}

// The scanning-related functions of the driver class, which depend on lexer-related objects
void
RStataDriver::scan_begin()
{
    buf = yy_scan_string(text.c_str());
    yy_switch_to_buffer(buf);
}

void
RStataDriver::scan_end()
{
    yy_delete_buffer(buf);
}

