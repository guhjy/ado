%skeleton "lalr1.cc" /* -*- C++ -*- */
%require "3.0.2"

%defines
%define parser_class_name { RStataParser }
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <memory>
    #include "RStata.hpp"
    class RStataDriver;
}

%param { RStataDriver& driver }

%locations

%code
{
    #include <string>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <Rcpp.h>
    #include "RStataDriver.hpp"

    void yy::RStataParser::error(const location_type& l, const std::string& m)
    {
            driver.error(l, m);
    }
}

/* Operator  precedence */
%precedence RELATIONAL
%precedence "+" "-"
%precedence EXPONENT
%precedence "["
%precedence "("

%token END         0   "end of file"

%token <std::string>
    PLUS            "+"
    LT_OP           "<"
    GT_OP           ">"
    LBRACE          "{"
    RBRACE          "}"
    COMMA           ","
    COLON           ":"
    NEG_OP          "!"
    STAR            "*"
    SLASH           "/"
    MINUS           "-"
    CARET           "^"
    ASSIGN          "="
    GE_OP           ">="
    LE_OP           "<="
    EQ_OP           "=="
    NE_OP           "!="
    OR_OP           "|"
    AND_OP          "&"
    LBRACKET        "["
    RBRACKET        "]"
    LPAREN          "("
    RPAREN          ")"
    NEWLINE         "\n"
;

/* Literals of various fundamental types */
%token <NumberExprNode *> NUMBER NUMBER_MISSING
%token <IdentExprNode *> IDENT
%token <StringExprNode *> STRING_LITERAL STRING_MISSING
%token <DatetimeExprNode *> DATE TIME DATETIME

/* Commands with unusual enough syntax they have to be parsed separately */
%token <EmbeddedRCmd *> EMBEDDED_R;
%token <GeneralStataCmd *> QUIETLY CAPTURE NOISILY /* Prefix commands that can be used without a colon */
%token <IdentExprNode *> MERGE

/* Command components and keywords */
%token <std::string> USING IF IN
%token <StringExprNode *> MERGE_SPEC

/* Nonterminal token types */
%type <BranchExprNode *> translation_unit external_statement compound_cmd cmds modifier_cmd_list

%type <GeneralStataCmd *> modifier_cmd
%type <BranchExprNode *> cmd nonmodifier_cmd

%type <std::string> assignment_operator unary_operator power_operator equality_operator
%type <std::string> multiplication_operator additive_operator relational_operator

%type <BranchExprNode *> if_clause in_clause weight_clause using_clause

%type <BranchExprNode *> expression
%type <BranchExprNode *> primary_expression postfix_expression power_expression
%type <BranchExprNode *> unary_expression multiplication_expression additive_expression
%type <BranchExprNode *> relational_expression equality_expression logical_and_expression logical_or_expression

%type <BranchExprNode *> option
%type <BranchExprNode *> option_list argument_expression_list expression_list

%start translation_unit
%%

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

translation_unit:
      external_statement
    {
        driver.ast = $1;
        $$ = $1;
    }
    | translation_unit "\n" external_statement
    {
        $1->appendChild($3);
        driver.ast = $1;
        $$ = $1;
    }
    ;

external_statement:
      cmd
    {
        BranchExprNode *node = new BranchExprNode("cmd_list", "");
        node->appendChild($1);
        $$ = node;
    }
    | compound_cmd
    ;

compound_cmd:
    "{" cmds "}"
    {
        $$ = $2;
    }
    ;

cmds:
      cmd
    {
        BranchExprNode *node = new BranchExprNode("cmd_list", "");
        node->appendChild($1);
        $$ = node;
    }
    | cmds "\n" cmd
    {
        $1->appendChild($3);
        $$ = $1;
    }
    ;

cmd:
      EMBEDDED_R
    {
        $$ = $1;
    }
    | modifier_cmd_list nonmodifier_cmd
    {
        $1->appendChild($2);
        $$ = $1;
    }
    | modifier_cmd_list ":" nonmodifier_cmd
    {
        $1->appendChild($3);
        $$ = $1;
    }
    | modifier_cmd_list nonmodifier_cmd ":" nonmodifier_cmd
    {
        $1->appendChild($2);
        $2->setChildren({$4});
        $$ = $1;
    }
    ;

modifier_cmd:
      CAPTURE
    | QUIETLY
    | NOISILY
    ;

modifier_cmd_list:
      modifier_cmd
    {
        BranchExprNode *node = new BranchExprNode("modifier_cmd_list", "");
        node->appendChild($1);
        $$ = node;
    }
    | modifier_cmd_list modifier_cmd
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

nonmodifier_cmd:
      compound_cmd
    {
        $$ = $1;
    }
    | IDENT expression_list if_clause in_clause weight_clause using_clause option_list
    {
        GeneralStataCmd *node = MakeGeneralStataCmd($1)
                                    .varlist($2)
                                    .if_clause($3)
                                    .in_clause($4)
                                    .weight($5)
                                    .using_clause($4)
                                    .options($7)
                                .create();
        $$ = node;
    }
    | IDENT
    {
        GeneralStataCmd *node = MakeGeneralStataCmd($1).create();
        $$ = node;
    }
    
    /* commands with unusual enough syntax to parse them separately */
    | MERGE MERGE_SPEC expression_list using_clause option_list
    {
        BranchExprNode *opts = $4;
        opts->appendChild($2);
        GeneralStataCmd *node = MakeGeneralStataCmd($1)
                                    .varlist($3)
                                    .using_clause($4)
                                    .options(opts)
                                .create();
        $$ = node;
    }
    ;


/*
 ************************************************************
 * The expression grammar. Note that varlists are expressions
 * syntactically, even if they're not semantically.
 ************************************************************
*/

assignment_operator:
    "="
    ;

unary_operator:
      "-"
    | "+"
    | "!"
    ;

power_operator:
    "^"
    ;

multiplication_operator:
      "*"
    | "/"
    ;

additive_operator:
      "+"
    | "-"
    ;

relational_operator:
      "<"
    | ">"
    | ">="
    | "<="
    ;

equality_operator:
      "=="
    | "!="
    ;

primary_expression:
      IDENT
    {
        $$ = $1;
    }
    | NUMBER
    {
        $$ = $1;
    }
    | NUMBER_MISSING
    {
        $$ = $1;
    }
    | STRING_LITERAL
    {
        $$ = $1;
    }
    | STRING_MISSING
    {
        $$ = $1;
    }
    | DATE
    {
        $$ = $1;
    }
    | TIME
    {
        $$ = $1;
    }
    | DATETIME
    {
        $$ = $1;
    }
    | "(" expression ")"
    {
        $$ = $2;
    }
    ;

postfix_expression:
      primary_expression
    | postfix_expression "[" expression "]" %prec "["
    {
        BranchExprNode *node = new BranchExprNode("expression", "[]");
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    | postfix_expression "(" ")" %prec "("
    {
        BranchExprNode *node = new BranchExprNode("expression", "()");
        node->appendChild($1);
        $$ = node;
    }
    | postfix_expression "(" argument_expression_list ")"
    {
        BranchExprNode *node = new BranchExprNode("expression", "()");
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

power_expression:
      postfix_expression %prec EXPONENT
    | power_expression power_operator postfix_expression %prec EXPONENT
    {
        BranchExprNode *node = new BranchExprNode("expression", "^");
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

unary_expression:
      power_expression
    | unary_operator power_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $1);
        node->appendChild($2);
        $$ = node;
    }
    ;

multiplication_expression:
      unary_expression
    | multiplication_expression multiplication_operator unary_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

additive_expression:
      multiplication_expression %prec "+"
    | additive_expression additive_operator multiplication_expression %prec "+"
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

relational_expression:
      additive_expression %prec RELATIONAL
    | relational_expression relational_operator additive_expression %prec RELATIONAL
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

equality_expression:
      relational_expression
    | equality_expression equality_operator relational_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

logical_and_expression:
      equality_expression
    | logical_and_expression "&" equality_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

logical_or_expression:
      logical_and_expression
    | logical_or_expression "|" logical_and_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

argument_expression_list:
      logical_or_expression
    {
        BranchExprNode *node = new BranchExprNode("expression_list", "");
        node->appendChild($1);
        $$ = node;
    }
    | argument_expression_list "," logical_or_expression
    {
        $1->appendChild($3);
        $$ = $1;
    }
    ;

expression:
      logical_or_expression
    | IDENT assignment_operator logical_or_expression
    {
        BranchExprNode *node = new BranchExprNode("expression", $2);
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

expression_list:
      expression
    {
        BranchExprNode *node = new BranchExprNode("expression_list", "");
        node->appendChild($1);
        $$ = node;
    }
    | expression_list expression
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

/*
 **************************************************
 * Options and option lists
 **************************************************
 */

option_list:
      %empty
    {
        $$ = new BranchExprNode("option_list", "");
    }
    | option_list "," option
    {
        $1->appendChild($3);
        $$ = $1;
    }
    ;

option:
      IDENT
    {
        BranchExprNode *node = new BranchExprNode("option", "");
        node->appendChild($1);
        $$ = node;
    }
    | IDENT "(" expression_list ")"
    {
        BranchExprNode *node = new BranchExprNode("option", "");
        node->setChildren( {$1, $3} );
        $$ = node;
    }
    ;

/*
 **************************************************
 * The weight clause
 **************************************************
 */

weight_clause:
      %empty
    {
        $$ = new BranchExprNode("weight_clause", "");
    }
    | "[" IDENT assignment_operator expression "]"
    {
        BranchExprNode *node = new BranchExprNode("weight_clause", "");
        node->setChildren( {$2, $4} );
        $$ = node;
    }
    ;

/*
 **************************************************
 * The if clause
 **************************************************
 */

if_clause:
      %empty
    {
        $$ = new BranchExprNode("if_clause", "");
    }
    | IF expression
    {
        BranchExprNode *node = new BranchExprNode("if_clause", "");
        node->appendChild($2);
        $$ = node;
    }
    ;

/*
 **************************************************
 * The in clause
 **************************************************
 */

in_clause:
      %empty
    {
        $$ = new BranchExprNode("in_clause", "");
    }
    | IN NUMBER "/" NUMBER
    {
        BranchExprNode *node = new BranchExprNode("in_clause", "");
        node->setChildren( {$2, $4} );
        $$ = node;
    }
    ;

/*
 **************************************************
 * The using clause
 **************************************************
 */

using_clause:
      %empty
    {
        $$ = new BranchExprNode("using_clause", "");
    }
    | USING STRING_LITERAL
    {
        BranchExprNode *node = new BranchExprNode("using_clause", "");
        node->appendChild($2);
        $$ = node;
    }
    | USING IDENT
    {
        BranchExprNode *node = new BranchExprNode("using_clause", "");
        node->appendChild($2);
        $$ = node;
    }
    ;

%%

