%{
#include <cstdio>
#include <cstring>
#include <iostream>
#include <Rcpp.h>
#include "rstata.hpp"

using namespace std;

void raise_condition(const string& msg, const string& type);

extern "C" int yylex(void);

void yyerror(STATA_CMD_LIST_T *cmdlist_ptr, const char *str)
{
        raise_condition(str, "error");
}
 
int yywrap()
{
        return 1;
} 
 
%}

%union {
    char *str;
}

%parse-param {STATA_CMD_LIST_T *cmdlist_ptr}
%define parse.error verbose
%start commands


%token <str> EMBEDDED_R;

%token <str> NUMBER
%token <str> NUMBER_MISSING
%token <str> BYTE INT LONG FLOAT DOUBLE;

%token <str> IDENT

%token <str> STRING_LITERAL STRING_MISSING STRING_TYPE_SPEC
%token <str> GT_OP LE_OP EQ_OP NE_OP OR_OP AND_OP

%token <str> STRING_FORMAT DATETIME_FORMAT NUMBER_FORMAT

%token <str> BY BYSORT XI QUIETLY
%token <str> USING IN IF PWEIGHT AWEIGHT

%token <str> CAPTURE CD CLEAR COUNT DESCRIBE DI DROP DUPLICATES
%token <str> EXIT GEN INSHEET KEEP LOG LOGIT LS MERGE MLOGIT
%token <str> ORDER OUTSHEET REGRESS RENAME REPLACE SAVE SET SORT
%token <str> SUM TABLE USE XTILE 

%%

/*
 ************************
 * The expression grammar
 ************************
 */

missing:
      STRING_MISSING
    | NUMBER_MISSING
    ;

primary_expression:
      NUMBER
    | IDENT
    | STRING_LITERAL
    | missing
    | '(' expression ')'
    ;

postfix_expression:
      primary_expression
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    ;

argument_expression_list:
      primary_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression:
      postfix_expression
    | unary_operator postfix_expression
    ;

unary_operator:
      '-'
    | '+'
    | '!'
    ;

mult_expression:
      unary_expression
    | mult_expression '*' unary_expression
    | mult_expression '/' unary_expression
    | mult_expression '%' unary_expression
    ;

additive_expression:
    mult_expression
    | additive_expression '+' mult_expression
    | additive_expression '-' mult_expression
    ;

relational_expression:
    additive_expression
    | relational_expression '<' additive_expression
    | relational_expression '>' additive_expression
    | relational_expression LE_OP additive_expression
    | relational_expression GT_OP additive_expression
    ;

equality_expression:
      relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression
    ;

and_expression:
      equality_expression
    | and_expression AND_OP equality_expression
    ;

or_expression:
      and_expression
    | or_expression OR_OP and_expression
    ;

assignment_expression:
    IDENT '=' or_expression
    ;

expression:
      assignment_expression
    | or_expression
    ;

/*
 **************************************************
 * Varlists - needs more fleshing out in the future
 **************************************************
 */

varlist:
      %empty
    | varlist IDENT
    ;

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

commands:
      %empty
    | commands command
    ;

command:
      embedded_r_cmd
    | capture_cmd
    | cd_cmd
    | clear_cmd
    | count_cmd
    | describe_cmd
    | di_cmd
    | drop_cmd
    | duplicates_cmd
    | exit_cmd
    | gen_cmd
    | insheet_cmd
    | keep_cmd
    | log_cmd
    | logit_cmd
    | ls_cmd
    | merge_cmd
    | mlogit_cmd
    | order_cmd
    | outsheet_cmd
    | regress_cmd
    | rename_cmd
    | replace_cmd
    | save_cmd
    | set_cmd
    | sort_cmd
    | sum_cmd
    | table_cmd
    | use_cmd
    | xtile_cmd
    ;

embedded_r_cmd:
    EMBEDDED_R
    {
        
    }
    ;

/*
 **************************
 * The usual Stata commands
 **************************
 */

exit_cmd:
    EXIT
    {
        raise_condition("Exit requested", "exit");
    }
    ;

gen_cmd:
    GEN assignment_expression
    {
    }
    ;

insheet_cmd:
    INSHEET USING STRING_LITERAL
    {
        GeneralStataCmd cmd = MakeGeneralStataCmd($1)
                                .using_filename($3)
                                .create();
        
        ADD_TO_CMD_LIST(cmd, cmdlist_ptr)
    }
    ;

capture_cmd:
      CAPTURE
    | CAPTURE ':' command
    {

    }
    ;

cd_cmd:
    CD STRING_LITERAL
    {

    }
    ;

clear_cmd:
      CLEAR
    | CLEAR IDENT
    {

    }
    ;

count_cmd:
    COUNT
    {

    }
    ;

describe_cmd:
    DESCRIBE
    {

    }
    ;

di_cmd:
    DI
    {

    }
    ;

drop_cmd:
    DROP
    {

    }
    ;

duplicates_cmd:
    DUPLICATES
    {

    }
    ;

keep_cmd:
    KEEP
    {

    }
    ;

log_cmd:
    LOG
    {

    }
    ;

logit_cmd:
    LOGIT
    {

    }
    ;

ls_cmd:
    LS
    {

    }
    ;

merge_cmd:
    MERGE
    {

    }
    ;

mlogit_cmd:
    MLOGIT
    {

    }
    ;

order_cmd:
    ORDER
    {

    }
    ;

outsheet_cmd:
    OUTSHEET
    {

    }
    ;

regress_cmd:
    REGRESS
    {

    }
    ;

rename_cmd:
    RENAME
    {

    }
    ;

replace_cmd:
    REPLACE
    {

    }
    ;

save_cmd:
    SAVE
    {

    }
    ;

set_cmd:
    SET
    {

    }
    ;

sort_cmd:
    SORT
    {

    }
    ;

sum_cmd:
      SUM varlist
    {

    }
    ;

table_cmd:
      TABLE IDENT
    {

    }
    ;

use_cmd:
    USE
    {

    }
    ;

xtile_cmd:
    XTILE
    {

    }
    ;

%%

using namespace Rcpp;

void
raise_condition(const string& msg, const string& type)
{
  List cond;
  cond["message"] = msg;
  cond["call"] = R_NilValue;
  cond.attr("class") = CharacterVector::create(type, "condition");
  Function stopper("stop");
  stopper(cond);
}
