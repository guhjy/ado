%{
#include <Rcpp.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include "rstata.h"

using namespace std;

void raise_condition(const string& msg, const string& type);

extern "C" int yylex(void);

void yyerror(STATA_CMD_LIST_T *cmdlist_ptr, const char *str)
{
        raise_condition(str, "error");
}
 
int yywrap()
{
        return 1;
} 
  
%}

%union {
    char *str;
    int num;
}

%parse-param {STATA_CMD_LIST_T *cmdlist_ptr}
%define parse.error verbose
%start commands

%token <num> NUMBER
%token <str> IDENT STRING_LITERAL
%token <str> GT_OP LE_OP EQ_OP NE_OP OR_OP AND_OP

%token <str> BY BYSORT XI QUIETLY
%token <str> USING IN IF PWEIGHT AWEIGHT

%token <str> INSHEET TABLE SUM DI EXIT
%token <str> APPEND CD CLEAR CODEBOOK COLLAPSE COMPARE COUNT
%token <str> DESCRIBE DESTRING DROP DUPLICATES EGEN FORMAT GENERATE
%token <str> INFILE INSPECT KEEP LABEL LIST LOG LS MEMORY MERGE
%token <str> MOVE MVDECODE MVENCODE ORDER OUTFILE PRESERVE USE
%token <str> QUERY RANGE RECAST RECODE RENAME REPLACE RESHAPE
%token <str> HELP ASSERT PROBIT TTEST PWCORR CORRELATE TEST PREDICT
%token <str> RESTORE SAVE SET SORT MLOGIT REGRESS LOGIT CI


%%

commands:
    | commands command
    ;

command:
      insheet_cmd
    | table_cmd
    | sum_cmd
    | di_cmd
    | exit_cmd
    | append_cmd
    | cd_cmd
    | clear_cmd
    | codebook_cmd
    | collapse_cmd
    | compare_cmd
    | count_cmd
    | describe_cmd
    | destring_cmd
    | drop_cmd
    | duplicates_cmd
    | egen_cmd
    | format_cmd
    | generate_cmd
    | infile_cmd
    | inspect_cmd
    | keep_cmd
    | label_cmd
    | list_cmd
    | log_cmd
    | ls_cmd
    | memory_cmd
    | merge_cmd
    | move_cmd
    | mvdecode_cmd
    | mvencode_cmd
    | order_cmd
    | outfile_cmd
    | preserve_cmd
    | query_cmd
    | range_cmd
    | recast_cmd
    | recode_cmd
    | rename_cmd
    | replace_cmd
    | reshape_cmd
    | restore_cmd
    | save_cmd
    | set_cmd
    | sort_cmd
    | help_cmd
    | assert_cmd
    | probit_cmd
    | ttest_cmd
    | pwcorr_cmd
    | correlate_cmd
    | test_cmd
    | predict_cmd
    | mlogit_cmd
    | regress_cmd
    | logit_cmd
    | ci_cmd
    | use_cmd
    ;

primary_expression:
      NUMBER
    | IDENT
    | STRING_LITERAL
    | '(' expression ')'
    ;

postfix_expression:
      primary_expression
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    ;

argument_expression_list:
      primary_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression:
      postfix_expression
    | unary_operator postfix_expression
    ;

unary_operator:
      '-'
    | '+'
    | '!'
    ;

mult_expression:
      unary_expression
    | mult_expression '*' unary_expression
    | mult_expression '/' unary_expression
    | mult_expression '%' unary_expression
    ;

additive_expression:
    mult_expression
    | additive_expression '+' mult_expression
    | additive_expression '-' mult_expression
    ;

relational_expression:
    additive_expression
    | relational_expression '<' additive_expression
    | relational_expression '>' additive_expression
    | relational_expression LE_OP additive_expression
    | relational_expression GT_OP additive_expression
    ;

equality_expression:
      relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression
    ;

and_expression:
      equality_expression
    | and_expression AND_OP equality_expression
    ;

or_expression:
      and_expression
    | or_expression OR_OP and_expression
    ;

assignment_expression:
    IDENT '=' or_expression
    ;

expression:
      assignment_expression
    | or_expression
    ;

varlist:
    | varlist IDENT
    ;

append_cmd:
    syntax
    {
        
    }
    ;

cd_cmd:
    syntax
    {
        
    }
    ;

clear_cmd:
    syntax
    {
        
    }
    ;

codebook_cmd:
    syntax
    {
        
    }
    ;

collapse_cmd:
    syntax
    {
        
    }
    ;

compare_cmd:
    syntax
    {
        
    }
    ;

count_cmd:
    syntax
    {
        
    }
    ;

describe_cmd:
    syntax
    {
        
    }
    ;

destring_cmd:
    syntax
    {
        
    }
    ;

drop_cmd:
    syntax
    {
        
    }
    ;

duplicates_cmd:
    syntax
    {
        
    }
    ;

egen_cmd:
    syntax
    {
        
    }
    ;

format_cmd:
    syntax
    {
        
    }
    ;

generate_cmd:
    syntax
    {
        
    }
    ;

infile_cmd:
    syntax
    {
        
    }
    ;

inspect_cmd:
    syntax
    {
        
    }
    ;

keep_cmd:
    syntax
    {
        
    }
    ;

label_cmd:
    syntax
    {
        
    }
    ;

list_cmd:
    syntax
    {
        
    }
    ;

log_cmd:
    syntax
    {
        
    }
    ;

ls_cmd:
    syntax
    {
        
    }
    ;

memory_cmd:
    syntax
    {
        
    }
    ;

merge_cmd:
    syntax
    {
        
    }
    ;

move_cmd:
    syntax
    {
        
    }
    ;

mvdecode_cmd:
    syntax
    {
        
    }
    ;

mvencode_cmd:
    syntax
    {
        
    }
    ;

order_cmd:
    syntax
    {
        
    }
    ;

outfile_cmd:
    syntax
    {
        
    }
    ;

preserve_cmd:
    syntax
    {
        
    }
    ;

query_cmd:
    syntax
    {
        
    }
    ;

range_cmd:
    syntax
    {
        
    }
    ;

recast_cmd:
    syntax
    {
        
    }
    ;

recode_cmd:
    syntax
    {
        
    }
    ;

rename_cmd:
    syntax
    {
        
    }
    ;

replace_cmd:
    syntax
    {
        
    }
    ;

reshape_cmd:
    syntax
    {
        
    }
    ;

restore_cmd:
    syntax
    {
        
    }
    ;

save_cmd:
    syntax
    {
        
    }
    ;

set_cmd:
    syntax
    {
        
    }
    ;

sort_cmd:
    syntax
    {
        
    }
    ;

exit_cmd:
    EXIT
    {
        raise_condition("Exit requested", "exit");
    }
    ;

help_cmd:
    syntax
    {
        
    }
    ;

assert_cmd:
    syntax
    {
        
    }
    ;

probit_cmd:
    syntax
    {
        
    }
    ;

ttest_cmd:
    syntax
    {
        
    }
    ;

pwcorr_cmd:
    syntax
    {
        
    }
    ;

correlate_cmd:
    syntax
    {
        
    }
    ;

test_cmd:
    syntax
    {
        
    }
    ;

predict_cmd:
    syntax
    {
        
    }
    ;

mlogit_cmd:
    syntax
    {
        
    }
    ;

regress_cmd:
    syntax
    {
        
    }
    ;

logit_cmd:
    syntax
    {
        
    }
    ;

ci_cmd:
    syntax
    {
        
    }
    ;

use_cmd:
    syntax
    {
        
    }
    ;

insheet_cmd:
    INSHEET USING STRING_LITERAL
    {
        STATA_CMD_T cmd = 
        {
            .verb = $1,
            
            .has_modifiers = 0,
            .modifiers = NULL,
            
            .has_varlist = 0,
            .varlist = NULL,
            
            .has_assign = 0,
            .assign_stmt = NULL,
            
            .has_if = 0,
            .if_exp = NULL,
            
            .has_range = 0,
            .range_lower = 0,
            .range_upper = 0,
            
            .has_weight = 0,
            .weight = NULL,
            
            .has_using = 1,
            .using_filename = $3,

            .has_options = 0,
            .options = NULL
        };

        STATA_CMD_LIST_T cmdlist =
        {
            .current = &cmd,
            .next = NULL
        };
        
        cmdlist_ptr = &cmdlist;
    }
    ;

table_cmd:
      TABLE IDENT
    | TABLE IDENT IDENT
    {
    }
    ;

sum_cmd:
   SUM varlist 
    {
    }
    ;

di_cmd:
    DI expression
    {
    }
    ;
%%

using namespace Rcpp;

void
raise_condition(const string& msg, const string& type)
{
  List cond;
  cond["message"] = msg;
  cond["call"] = R_NilValue;
  cond.attr("class") = CharacterVector::create(type, "condition");
  Function stopper("stop");
  stopper(cond);
}
