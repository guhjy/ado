%{
#include <Rcpp.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include "rstata.h"

using namespace std;

void raise_condition(const string& msg, const string& type);

extern "C" int yylex(void);

void yyerror(STATA_CMD_LIST_T *cmdlist_ptr, const char *str)
{
        raise_condition(str, "error");
}
 
int yywrap()
{
        return 1;
} 
  
%}

%token NUMBER IDENT STRING_LITERAL
%token INSHEET TABLE SUM DI EXIT
%token USING BY IN IF PWEIGHT AWEIGHT
%token GT_OP LE_OP EQ_OP NE_OP OR_OP AND_OP

%union {
    char *str;
    int num;
}

%type <str> INSHEET
%type <str> USING
%type <str> STRING_LITERAL

%parse-param {STATA_CMD_LIST_T *cmdlist_ptr}
%define parse.error verbose
%start commands

%%

commands:
    | commands command
    ;

command:
      insheet_cmd
    | table_cmd
    | sum_cmd
    | di_cmd
    | exit_cmd
    ;

primary_expression:
      NUMBER
    | IDENT
    | STRING_LITERAL
    | '(' expression ')'
    ;

postfix_expression:
      primary_expression
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    ;

argument_expression_list:
      primary_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression:
      postfix_expression
    | unary_operator postfix_expression
    ;

unary_operator:
      '-'
    | '+'
    | '!'
    ;

mult_expression:
      unary_expression
    | mult_expression '*' unary_expression
    | mult_expression '/' unary_expression
    | mult_expression '%' unary_expression
    ;

additive_expression:
    mult_expression
    | additive_expression '+' mult_expression
    | additive_expression '-' mult_expression
    ;

relational_expression:
    additive_expression
    | relational_expression '<' additive_expression
    | relational_expression '>' additive_expression
    | relational_expression LE_OP additive_expression
    | relational_expression GT_OP additive_expression
    ;

equality_expression:
      relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression
    ;

and_expression:
      equality_expression
    | and_expression AND_OP equality_expression
    ;

or_expression:
      and_expression
    | or_expression OR_OP and_expression
    ;

assignment_expression:
    IDENT '=' or_expression
    ;

expression:
      assignment_expression
    | or_expression
    ;

varlist:
    | varlist IDENT
    ;

exit_cmd:
    EXIT
    {
        raise_condition("Exit requested", "exit");
    }
    ;

insheet_cmd:
    INSHEET USING STRING_LITERAL
    {
        STATA_CMD_T cmd = 
        {
            .verb = $1,
            
            .has_modifiers = 0,
            .modifiers = NULL,
            
            .has_varlist = 0,
            .varlist = NULL,
            
            .has_assign = 0,
            .assign_stmt = NULL,
            
            .has_if = 0,
            .if_exp = NULL,
            
            .has_range = 0,
            .range_lower = 0,
            .range_upper = 0,
            
            .has_weight = 0,
            .weight = NULL,
            
            .has_using = 1,
            .using_filename = $3,

            .has_options = 0,
            .options = NULL
        };

        STATA_CMD_LIST_T cmdlist =
        {
            .current = &cmd,
            .next = NULL
        };
        
        cmdlist_ptr = &cmdlist;
    }
    ;

table_cmd:
      TABLE IDENT
    | TABLE IDENT IDENT
    {
    }
    ;

sum_cmd:
   SUM varlist 
    {
    }
    ;

di_cmd:
    DI expression
    {
    }
    ;
%%

using namespace Rcpp;

void
raise_condition(const string& msg, const string& type)
{
  List cond;
  cond["message"] = msg;
  cond["call"] = R_NilValue;
  cond.attr("class") = CharacterVector::create(type, "condition");
  Function stopper("stop");
  stopper(cond);
}
