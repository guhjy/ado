%skeleton "lalr1.cc" /* -*- C++ -*- */
%require "3.0.2"

%defines
%define parser_class_name { RStataParser }
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%define api.pure
%pure-parser

%code requires
{
#include <memory>
#include "RStata.hpp"
class RStataDriver;

#define YY_DECL int yylex(yy::RStataParser::semantic_type* yylval_param, yy::RStataParser::location_type* llocp, RStataDriver& driver)

#define R_ACTION(node) if(driver.callbacks == 1) { driver.wrap_cmd_action(node->as_R_object()); }
}

%param { RStataDriver& driver }
%locations

%union
{
    std::string   *str;
    ExprNode      *node;
}

%code
{
#include "ado.tab.hpp"
#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <Rcpp.h>
#include "RStataDriver.hpp"

YY_DECL;

void yy::RStataParser::error(const location_type& l, const std::string& m)
{
        driver.error(l, m);
}
}

/* Operator  precedence */
%precedence RELATIONAL
%precedence "+" "-"
%precedence EXPONENT
%precedence "["
%precedence "("

/* Not used, but invokes error handling if seen */
%token ILLEGAL_CHARACTER

/* EOF and command separators */
%token
    END 0
    NEWLINE
    SEMICOLON       ";"
;

/* Operators or symbols whose values don't need to be passed up to the next layer */
%token
    LPAREN          "("
    RPAREN          ")"
    COMMA           ","
    LBRACE          "{"
    RBRACE          "}"
    LBRACKET        "["
    RBRACKET        "]"
    COLON           ":"
    ASSIGN          "="
;

/* Operators whose values need to be passed up to the next layer */
%token <str>
    PLUS            "+"
    LT_OP           "<"
    GT_OP           ">"
    NEG_OP          "!"
    STAR            "*"
    SLASH           "/"
    MINUS           "-"
    CARET           "^"
    GE_OP           ">="
    LE_OP           "<="
    EQ_OP           "=="
    NE_OP           "!="
    OR_OP           "|"
    AND_OP          "&"
    FACT_CROSS      "##"
    CROSS           "#"
;

                /* Literals of various fundamental types */
%token <node>   NUMBER NUMBER_MISSING
%token <node>   IDENT
%token <node>   STRING_LITERAL STRING_MISSING
%token <node>   DATE DATETIME

                /* Type specifiers */
%token <str>    BYTE INT LONG FLOAT DOUBLE STRING_TYPE_SPEC

                /* Formats */
%token <str>    STRING_FORMAT DATETIME_FORMAT NUMBER_FORMAT

                /* Commands with unusual enough syntax they have to be parsed separately */
%token <node>   EMBEDDED_R
%token <node>   BY XI
%token <node>   QUIETLY CAPTURE NOISILY /* Prefix commands that can be used without a colon */
%token <node>   GENERATE RECAST DISPLAY FORMAT MERGE

                /* Command components and keywords */
%token          USING IF IN
%token <str>    MERGE_SPEC

                /* Factor variable operators */
%token <node>   CONT_OPERATOR IND_OPERATOR BASE_OPERATOR OMIT_OPERATOR

                /* Nonterminal token types */
%type <node>    translation_unit external_statement compound_cmd cmds modifier_cmd_list cmd
%type <node>    error

%type <node>    modifier_cmd nonmodifier_cmd long_modifier_cmd

%type <node>    unary_factor_operator

%type <str>     unary_operator power_operator equality_operator
%type <str>     multiplication_operator additive_operator relational_operator logical_operator
%type <str>     cross_operator
%type <str>     type_spec format_spec

%type <node>    if_clause in_clause weight_clause using_clause

%type <node>    expression
%type <node>    primary_expression postfix_expression power_expression
%type <node>    unary_expression multiplication_expression additive_expression
%type <node>    relational_expression equality_expression logical_expression
%type <node>    cross_expression unary_factor_expression

%type <node>    option options
%type <node>    option_list argument_expression_list expression_list

%destructor { }                 translation_unit
%destructor { delete $$; }      <str>
%destructor { delete $$; }      <node>

%start translation_unit
%%

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

translation_unit:
      external_statement
    {
        ExprNode *node = new ExprNode("rstata_compound_cmd");
        
        if($1 != NULL)
            node->appendChild($1);
        
        $$ = node;
        
        driver.ast = node;
    }
    | translation_unit external_statement
    {
        if($2 != NULL)
            $1->appendChild($2);
        
        $$ = $1;
        
        driver.ast = $1;
    }
    | error
    ;

external_statement:
      cmd
    | compound_cmd
    ;

cmd_sep:
      NEWLINE
    | ";"
    ;

compound_cmd:
    "{" cmds "}"
    {
        $$ = $2;
    }
    ;

cmds:
      cmd
    {
        ExprNode *node = new ExprNode("rstata_compound_cmd");
        
        if($1 != NULL)
            node->appendChild($1);
        
        $$ = node;
    }
    | compound_cmd
    {
        $$ = $1;
    }
    | cmds cmd
    {
        if($2 != NULL)
            $1->appendChild($2);

        $$ = $1;
    }
    | cmds compound_cmd
    {
        $1->appendChild($2);

        $$ = $1;
    }
    ;

cmd:
      cmd_sep
    {
        $$ = NULL; // or an ExprNode?
    }
    | EMBEDDED_R cmd_sep
    {
        R_ACTION($1);
        
        $$ = $1;
    }
    | nonmodifier_cmd cmd_sep
    {
        R_ACTION($1);
        
        $$ = $1;
    }
    | modifier_cmd_list nonmodifier_cmd cmd_sep
    {
        $1->appendChild("main_cmd", $2);
        
        R_ACTION($1);
        
        $$ = $1;
    }
    | modifier_cmd_list ":" nonmodifier_cmd cmd_sep
    {
        $1->appendChild("main_cmd", $3);

        R_ACTION($1);
        
        $$ = $1;
    }
    | modifier_cmd_list compound_cmd cmd_sep
    {
        $1->appendChild("main_cmd", $2);
        
        R_ACTION($1);
        
        $$ = $1;
    }
    | modifier_cmd_list ":" compound_cmd cmd_sep
    {
        $1->appendChild("main_cmd", $3);
        
        R_ACTION($1);
        
        $$ = $1;
    }

    | modifier_cmd_list long_modifier_cmd ":" nonmodifier_cmd cmd_sep
    {
        $1->appendChild($2);
        $1->appendChild("main_cmd", $4);
        
        R_ACTION($1);
        
        $$ = $1;
    }
    | modifier_cmd_list long_modifier_cmd ":" compound_cmd cmd_sep
    {
        $1->appendChild($2);
        $1->appendChild("main_cmd", $4);
        
        R_ACTION($1);
        
        $$ = $1;
    }
    ;

modifier_cmd:
      CAPTURE
    | QUIETLY
    | NOISILY
    ;

long_modifier_cmd:
      BY expression_list option_list 
    {
        $1->appendChild("varlist", $2);
        
        if($3->nChildren() > 0)
          $1->appendChild("option_list", $3);
        
        $$ = $1;
    }
    | XI option_list
    {
      if($2->nChildren() > 0)
        $1->appendChild("option_list", $2);
      
      $$ = $1;
    }
    ;

modifier_cmd_list:
      modifier_cmd
    {
        ExprNode *node = new ExprNode("rstata_modifier_cmd_list");
        node->appendChild($1);
        $$ = node;
    }
    | modifier_cmd_list modifier_cmd
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

nonmodifier_cmd:
     IDENT expression_list if_clause in_clause weight_clause using_clause option_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_general_cmd"});
        node->appendChild("verb", $1);
        node->appendChild("varlist", $2);
        
        if($3->nChildren() > 0)
            node->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("weight_clause", $5);

        if($6->nChildren() > 0)
            node->appendChild("using_clause", $6);

        if($7->nChildren() > 0)
            node->appendChild("option_list", $7);

        $$ = node;
    }
    | IDENT
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_general_cmd"});
        node->appendChild("verb", $1);
        $$ = node;
    }
    
    /* commands with unusual enough syntax to parse them separately */
    | MERGE MERGE_SPEC expression_list using_clause option_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("merge_spec", *($2));
        
        if($3->nChildren() > 0)
            node->appendChild("varlist", $3);
        
        if($4->nChildren() > 0)
            node->appendChild("using_clause", $4);
        
        if($5->nChildren() > 0)
            node->appendChild("option_list", $5);
        
        $$ = node;
    }
    | GENERATE expression if_clause in_clause option_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->appendChild("expression", $2);
        
        if($3->nChildren() > 0)
            node->appendChild("if_clause", $3);

        if($4->nChildren() > 0)
            node->appendChild("in_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("option_list", $5);
        
        $$ = node;
    }
    | GENERATE type_spec expression if_clause in_clause option_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("type_spec", *($2));
        node->appendChild("expression", $3);
        
        if($4->nChildren() > 0)
            node->appendChild("if_clause", $4);

        if($5->nChildren() > 0)
            node->appendChild("in_clause", $5);
        
        if($6->nChildren() > 0)
            node->appendChild("option_list", $6);
        
        $$ = node;
    }
    | RECAST type_spec expression_list option_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("type_spec", *($2));

        node->appendChild("varlist", $3);
        
        if($4->nChildren() > 0)
            node->appendChild("option_list", $4);
        
        $$ = node;
    }
    | DISPLAY format_spec expression
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("format_spec", *($2));
        node->appendChild("expression", $3);

        $$ = node;
    }
    | DISPLAY expression
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->appendChild("expression", $2);
        
        $$ = node;
    }
    | FORMAT format_spec expression_list
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("format_spec", *($2));
        node->appendChild("varlist", $3);

        $$ = node;
    }
    | FORMAT expression_list format_spec
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->addData("format_spec", *($3));
        node->appendChild("varlist", $2);

        $$ = node;
    }
    | XI expression_list option_list /* only necessary because this is a keyword */
    {
        ExprNode *node = new ExprNode({"rstata_cmd", "rstata_special_cmd"});
        node->appendChild("verb", $1);
        node->appendChild("varlist", $2);
        node->appendChild("option_list", $3);

        $$ = node;
    }

    ;

type_spec:
      BYTE
    | INT
    | LONG
    | FLOAT
    | DOUBLE
    | STRING_TYPE_SPEC
    ;

format_spec:
      STRING_FORMAT
    | NUMBER_FORMAT
    | DATETIME_FORMAT
    ;

/*
 ************************************************************
 * The expression grammar. Note that varlists are expressions
 * syntactically, even if they're not semantically.
 ************************************************************
*/

assignment_operator:
    "="
    ;

unary_operator:
      "-"
    | "+"
    | "!"
    ;
    
unary_factor_operator:
      CONT_OPERATOR
    | BASE_OPERATOR
    | IND_OPERATOR
    | OMIT_OPERATOR
    ;

power_operator:
    "^"
    ;

multiplication_operator:
      "*"
    | "/"
    ;

additive_operator:
      "+"
    | "-"
    ;

relational_operator:
      "<"
    | ">"
    | ">="
    | "<="
    ;

equality_operator:
      "=="
    | "!="
    ;

logical_operator:
      "&"
    | "|"
    ;

cross_operator:
      "##"
    | "#"
    ;

primary_expression:
      IDENT
    | NUMBER
    | NUMBER_MISSING
    | STRING_LITERAL
    | STRING_MISSING
    | DATE
    | DATETIME
    | "(" expression ")"
    {
        $$ = $2;
    }
    ;

unary_factor_expression:
      primary_expression
    | unary_factor_operator primary_expression
    {
        $1->appendChild("left", $2);
        
        $$ = $1; // ExprNode constructed by the lexer, which is a bit of a hack
    }
    ;

cross_expression:
      unary_factor_expression
    | cross_expression cross_operator unary_factor_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_cross_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

postfix_expression:
      cross_expression %prec "["
    | postfix_expression "[" expression "]" %prec "["
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_postfix_expression"});
        node->addData("verb", std::string("[]"));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        
        $$ = node;
    }
    | postfix_expression "(" ")" %prec "("
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_postfix_expression"});
        node->addData("verb", std::string("()"));
        node->appendChild("left", $1);
        
        $$ = node;
    }
    | postfix_expression "(" argument_expression_list ")"
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_postfix_expression"});
        node->addData("verb", std::string("()"));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        
        $$ = node;
    }
    ;

power_expression:
      postfix_expression %prec EXPONENT
    | power_expression power_operator postfix_expression %prec EXPONENT
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_arithmetic_expression", "rstata_power_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

unary_expression:
      power_expression
    | unary_operator power_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_arithmetic_expression", "rstata_unary_expression"});
        node->addData("verb", *($1));
        node->appendChild("right", $2);
        $$ = node;
    }
    ;

multiplication_expression:
      unary_expression
    | multiplication_expression multiplication_operator unary_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_arithmetic_expression", "rstata_multiplication_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

additive_expression:
      multiplication_expression %prec "+"
    | additive_expression additive_operator multiplication_expression %prec "+"
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_arithmetic_expression", "rstata_additive_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

relational_expression:
      additive_expression %prec RELATIONAL
    | relational_expression relational_operator additive_expression %prec RELATIONAL
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_relational_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

equality_expression:
      relational_expression
    | equality_expression equality_operator relational_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_equality_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

logical_expression:
      equality_expression
    | logical_expression logical_operator equality_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_logical_expression"});
        node->addData("verb", *($2));
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

argument_expression_list:
      logical_expression
    {
        ExprNode *node = new ExprNode("rstata_argument_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | argument_expression_list "," logical_expression
    {
        $1->appendChild($3);
        
        $$ = $1;
    }
    ;

expression:
      logical_expression
    | logical_expression assignment_operator logical_expression
    {
        ExprNode *node = new ExprNode({"rstata_expression", "rstata_assignment_expression"});
        node->addData("verb", "=");
        node->appendChild("left", $1);
        node->appendChild("right", $3);
        $$ = node;
    }
    ;

expression_list:
      expression
    {
        ExprNode *node = new ExprNode("rstata_expression_list");
        node->appendChild($1);
        $$ = node;
    }
    | expression_list expression
    {
        $1->appendChild($2);
        $$ = $1;
    }
    | type_spec "(" expression_list ")"
    {
        ExprNode *node = new ExprNode("rstata_type_constructor");
        node->addData("type_spec", *($1));
        node->appendChild("varlist", $3);
        
        $$ = node;
    }
    ;

/*
 **************************************************
 * Options and option lists
 **************************************************
 */

option_list:
      %empty
    {
        $$ = new ExprNode("rstata_option_list");
    }
    | "," options
    {
        $$ = $2;
    }
    ;

options:
      option
    {
        ExprNode *node = new ExprNode("rstata_option_list");
        node->appendChild($1);
        $$ = node;
    }
    | options option
    {
        $1->appendChild($2);
        $$ = $1;
    }
    ;

option:
      IDENT
    {
        ExprNode *node = new ExprNode("rstata_option");
        node->appendChild("name", $1);
        
        $$ = node;
    }
    | IDENT "(" expression_list ")"
    {
        ExprNode *node = new ExprNode("rstata_option");
        node->appendChild("name", $1);
        node->appendChild("args", $3);
        
        $$ = node;
    }
    ;

/*
 **************************************************
 * The weight clause
 **************************************************
 */

weight_clause:
      %empty
    {
        $$ = new ExprNode("rstata_weight_clause");
    }
    | "[" IDENT assignment_operator expression "]"
    {
        ExprNode *node = new ExprNode("rstata_weight_clause");
        node->appendChild("left", $2);
        node->appendChild("right", $4);
        
        $$ = node;
    }
    ;

/*
 **************************************************
 * The if clause
 **************************************************
 */

if_clause:
      %empty
    {
        $$ = new ExprNode("rstata_if_clause");
    }
    | IF expression
    {
        ExprNode *node = new ExprNode("rstata_if_clause");
        node->appendChild("if_expression", $2);
        
        $$ = node;
    }
    ;

/*
 **************************************************
 * The in clause
 **************************************************
 */

in_clause:
      %empty
    {
        $$ = new ExprNode("rstata_in_clause");
    }
    | IN NUMBER "/" NUMBER /* failing to reference the "/" produces a spurious warning */
    {
        ExprNode *node = new ExprNode("rstata_in_clause");
        node->appendChild("upper", $2);
        node->appendChild("lower", $4);
        
        $$ = node;
    }
    ;

/*
 **************************************************
 * The using clause
 **************************************************
 */

using_clause:
      %empty
    {
        $$ = new ExprNode("rstata_using_clause");
    }
    | USING STRING_LITERAL
    {
        ExprNode *node = new ExprNode("rstata_using_clause");
        node->appendChild("filename", $2);
        
        $$ = node;
    }
    | USING IDENT
    {
        ExprNode *node = new ExprNode("rstata_using_clause");
        node->appendChild("filename", $2);
        
        $$ = node;
    }
    ;

%%

