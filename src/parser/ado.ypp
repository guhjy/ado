%{
#include <cstdio>
#include <cstring>
#include <iostream>
#include <Rcpp.h>
#include "rstata.hpp"

using namespace std;

void raise_condition(const string& msg, const string& type);

extern "C" int yylex(void);

void yyerror(std::vector<std::unique_ptr<BaseStataCmd>> *cmdlist_ptr, const char *str)
{
        raise_condition(str, "error");
}
 
int yywrap()
{
        return 1;
} 
 
%}

%union {
    char *str;
}

%parse-param {std::vector<std::unique_ptr<BaseStataCmd>> *cmdlist_ptr}
%define parse.error verbose
%start commands


%token <str> EMBEDDED_R;

%token <str> NUMBER
%token <str> NUMBER_MISSING
%token <str> BYTE INT LONG FLOAT DOUBLE;

%token <str> IDENT

%token <str> STRING_LITERAL STRING_MISSING STRING_TYPE_SPEC
%token <str> GT_OP LE_OP EQ_OP NE_OP OR_OP AND_OP

/* Formats */
%token <str> STRING_FORMAT DATETIME_FORMAT NUMBER_FORMAT

/* Weight specifiers and command component keywords */
%token <str> PWEIGHT AWEIGHT IWEIGHT FWEIGHT WEIGHT
%token <str> USING IN IF

/* Prefix commands */
%token <str> BY BYSORT XI QUIETLY CAPTURE NOISILY

/* Immediate commands */
%token <str> DISPLAY POWER BITESTI CCI CSI IRI MCCI ESIZEI
%token <str> PRTESTI SDTESTI SYMMI TABI TTESTI

/* Other commands */
%token <str> CD CLEAR COUNT DESCRIBE DROP DUPLICATES
%token <str> EXIT GEN INSHEET KEEP LOG LOGIT LS MERGE MLOGIT
%token <str> ORDER OUTSHEET REGRESS RENAME REPLACE SAVE SET SORT
%token <str> SUM TABLE USE XTILE 

%%

/*
 ************************
 * The expression grammar
 ************************
 */

missing:
      STRING_MISSING
    | NUMBER_MISSING
    ;

primary_expression:
      NUMBER
    | IDENT
    | STRING_LITERAL
    | missing
    | '(' expression ')'
    ;

postfix_expression:
      primary_expression
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    ;

argument_expression_list:
      primary_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression:
      postfix_expression
    | unary_operator postfix_expression
    ;

unary_operator:
      '-'
    | '+'
    | '!'
    ;

mult_expression:
      unary_expression
    | mult_expression '*' unary_expression
    | mult_expression '/' unary_expression
    | mult_expression '%' unary_expression
    ;

additive_expression:
    mult_expression
    | additive_expression '+' mult_expression
    | additive_expression '-' mult_expression
    ;

relational_expression:
    additive_expression
    | relational_expression '<' additive_expression
    | relational_expression '>' additive_expression
    | relational_expression LE_OP additive_expression
    | relational_expression GT_OP additive_expression
    ;

equality_expression:
      relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression
    ;

and_expression:
      equality_expression
    | and_expression AND_OP equality_expression
    ;

or_expression:
      and_expression
    | or_expression OR_OP and_expression
    ;

assignment_expression:
    IDENT '=' or_expression
    ;

expression:
      assignment_expression
    | or_expression
    ;

expression_list:
      %empty
    | expression_list expression
    ;

/*
 **************************************************
 * Varlists - needs more fleshing out in the future
 **************************************************
 */

varlist:
      %empty
    | varlist IDENT
    ;

/*
 **************************************************
 * Options and option lists
 **************************************************
 */

option_list:
      %empty
    | option_list option
    ;

option:
      IDENT
    | IDENT '(' option_arguments ')'
    ;

/* FIXME: option args are much more bespoke than this */
option_arguments:
      expression
    | option_arguments expression
    ;

/*
 **************************************************
 * Other command parts
 **************************************************
 */

weight:
    '[' weight_type '=' expression ']';

weight_type:
      WEIGHT
    | PWEIGHT
    | AWEIGHT
    | FWEIGHT
    | IWEIGHT
    ;

if_modifier:
    IF expression
    ;

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

commands:
      %empty
    | commands command
    ;

command:
      embedded_r_cmd
    | stata_cmd
    ;

stata_cmd:
      immediate_cmd
    | nonprefix_cmd_with_prefix
    | nonprefix_cmd
    ;

immediate_cmd:
    immediate_cmd_verb expression_list
    ;

immediate_cmd_verb:
      DISPLAY
    | POWER
    | BITESTI
    | CCI
    | CSI
    | IRI
    | MCCI
    | ESIZEI
    | PRTESTI
    | SDTESTI
    | SYMMI
    | TABI
    | TTESTI
    ;

colonless_prefix_cmd:
      CAPTURE
    | QUIETLY
    | NOISILY
    ;

colon_prefix_cmd:
      xi_cmd
    | by_cmd
    | bysort_cmd
    ;

colonless_prefix_applied:
      colonless_prefix_cmd nonprefix_cmd
    | colonless_prefix_cmd ':' nonprefix_cmd
    ;

colon_prefix_with_colonless_prefix:
      colonless_prefix_cmd colon_prefix_cmd
      ;

colon_prefix_applied:
      colon_prefix_with_colonless_prefix ':' nonprefix_cmd
    | colon_prefix_cmd ':' nonprefix_cmd
    ;

nonprefix_cmd_with_prefix:
      colonless_prefix_applied
    | colon_prefix_applied
    ;

nonprefix_cmd:
      general_nonprefix_cmd
    | special_nonprefix_cmd
    ;

general_nonprefix_cmd_verb:
      COUNT
    | DROP
    | KEEP
    | INSHEET
    | GEN
    | DESCRIBE
    | LOGIT
    | MLOGIT
    | ORDER
    | OUTSHEET
    | SORT
    | TABLE
    | REGRESS
    | REPLACE
    | SUM
    | XTILE
    ;

general_nonprefix_cmd:
      general_nonprefix_cmd_verb varlist
    | general_nonprefix_cmd_verb assignment_expression
    | 

special_nonprefix_cmd:
      cd_cmd
    | pwd_cmd
    | clear_cmd
    | exit_cmd
    | use_cmd
    | save_cmd
    | ls_cmd
    | rename_cmd
    | set_cmd
    
    | log_cmd
    | duplicates_cmd
    | merge_cmd
    ;

embedded_r_cmd:
    EMBEDDED_R
    {
        /* chop off the first and last three characters of yylval.str,
           which are the {{{ and }}} that begin and end this command */
        
        s = strdup(yylval.str);
        s[strlen(s) - 3] = '\0';
        s += 3;
        
        EmbeddedRCmd cmd = EmbeddedRCmd(s);
        ADD_TO_CMD_LIST(cmd, cmdlist_ptr)
    }
    ;

/*
 ******************************************
 * The colon-required Stata prefix commands
 ******************************************
 */

xi_cmd:
    XI
    {

    }
    ;

by_cmd:
    BY
    {

    }
    ;

bysort_cmd:
    BYSORT
    {

    }
    ;

/*
 *************************************
 * The "special" Stata non-prefix commands
 *************************************
 */

exit_cmd:
    EXIT
    {
        raise_condition("Exit requested", "exit");
    }
    ;

cd_cmd:
    CD STRING_LITERAL
    {

    }
    ;

clear_cmd:
      CLEAR
    | CLEAR IDENT
    {

    }
    ;

duplicates_cmd:
    DUPLICATES
    {

    }
    ;

log_cmd:
    LOG
    {

    }
    ;

ls_cmd:
    LS
    {

    }
    ;

merge_cmd:
    MERGE
    {

    }
    ;

rename_cmd:
    RENAME
    {

    }
    ;

save_cmd:
    SAVE
    {

    }
    ;

set_cmd:
    SET
    {

    }
    ;

table_cmd:
    TABLE IDENT
    {

    }
    ;

use_cmd:
    USE
    {

    }
    ;

%%

using namespace Rcpp;

void
raise_condition(const string& msg, const string& type)
{
  List cond;
  cond["message"] = msg;
  cond["call"] = R_NilValue;
  cond.attr("class") = CharacterVector::create(type, "condition");
  Function stopper("stop");
  stopper(cond);
}
