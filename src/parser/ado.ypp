%skeleton "lalr1.cc" /* -*- C++ -*- */
%require "3.0.2"

%defines
%define parser_class_name { RStataParser }
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%param { RStataDriver& driver }

%locations

%code
{
    #include <string>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <Rcpp.h>
    #include "RStata.hpp"
    #include "RStataDriver.hpp"

    void yy::RStataParser::error(const location_type& l, const std::string& m)
    {
            driver.error(l, m);
    }
     
    int yywrap()
    {
            return 1;
    } 
 
}

%token
    END 0   "end of file"
    

%token <BaseExprNode> NEWLINE
%token <BaseExprNode> EMBEDDED_R;

/* Literals of various fundamental types */
%token <BaseExprNode> NUMBER IDENT STRING_LITERAL
%token <BaseExprNode> NUMBER_MISSING STRING_MISSING DATE TIME DATETIME

/* Operators */
%token <BaseExprNode> GT_OP LT_OP EQ_OP NE_OP OR_OP AND_OP
%precedence RELATIONAL
%precedence '+' '-'
%precedence EXPONENT
%precedence '['
%precedence '('

/* Command components and keywords */
%token <BaseExprNode> USING IF IN

/* Commands with unusual enough syntax they have to be parsed separately */
%token <BaseExprNode> QUIETLY CAPTURE NOISILY /* Prefix commands that can be used without a colon */
%token <BaseExprNode> MERGE

%start translation_unit
%%

/*
 *************************************************
 * The start symbol, a "command" and escaping to R
 *************************************************
 */

translation_unit:
      external_statement
    | translation_unit NEWLINE external_statement
    ;

external_statement:
      cmd
    | compound_cmd
    ;

compound_cmd:
    '{' cmds '}'
    ;

cmds:
      cmd
    | cmds NEWLINE cmd
    ;

cmd:
      embedded_r_cmd
    | modifier_cmd_list nonmodifier_cmd
    | modifier_cmd_list ':' nonmodifier_cmd
    | modifier_cmd_list nonmodifier_cmd ':' nonmodifier_cmd
    ;

embedded_r_cmd:
    EMBEDDED_R
    ;

modifier_cmd:
      CAPTURE
    | QUIETLY
    | NOISILY
    ;

modifier_cmd_list:
      modifier_cmd
    | modifier_cmd_list modifier_cmd
    ;

nonmodifier_cmd:
      compound_cmd
    | special_cmd
    | IDENT expression_list if_clause in_clause weight_clause using_clause option_list
    | IDENT
    ;

special_cmd:
    merge_cmd
    ;

/*
 ************************************************************
 * The expression grammar. Note that varlists are expressions
 * syntactically, even if they're not semantically.
 ************************************************************
*/

assignment_operator:
    '='
    ;

unary_operator:
      '-'
    | '+'
    | '!'
    | '~'
    ;

power_operator:
    '^'
    ;

multiplication_operator:
      '*'
    | '/'
    | '%'
    ;

additive_operator:
      '+'
    | '-'
    ;

relational_operator:
      '<'
    | '>'
    | GT_OP
    | LT_OP
    ;

equality_operator:
      EQ_OP
    | NE_OP
    ;

primary_expression:
      IDENT
    | NUMBER
    | NUMBER_MISSING
    | STRING_LITERAL
    | STRING_MISSING
    | DATE
    | TIME
    | DATETIME
    | '(' expression ')'
    ;

postfix_expression:
      primary_expression
    | postfix_expression '[' expression ']' %prec '['
    | postfix_expression '(' ')' %prec '('
    | postfix_expression '(' argument_expression_list ')'
    ;

power_expression:
      postfix_expression %prec EXPONENT
    | power_expression power_operator postfix_expression %prec EXPONENT
    ;

unary_expression:
      power_expression
    | unary_operator power_expression
    ;

multiplication_expression:
      unary_expression
    | multiplication_expression multiplication_operator unary_expression
    ;

additive_expression:
      multiplication_expression %prec '+'
    | additive_expression additive_operator multiplication_expression %prec '+'
    ;

relational_expression:
      additive_expression %prec RELATIONAL
    | relational_expression relational_operator additive_expression %prec RELATIONAL
    ;

equality_expression:
      relational_expression
    | equality_expression equality_operator relational_expression
    ;

logical_and_expression:
      equality_expression
    | logical_and_expression AND_OP equality_expression
    ;

logical_or_expression:
      logical_and_expression
    | logical_or_expression OR_OP logical_and_expression
    ;

argument_expression_list:
      logical_or_expression
    | argument_expression_list ',' logical_or_expression
    ;

expression:
      logical_or_expression
    | IDENT assignment_operator logical_or_expression
    ;

expression_list:
      expression
    | expression_list expression
    ;

/*
 **************************************************
 * Options and option lists
 **************************************************
 */

option_list:
      %empty
    | option_list ',' option
    ;

option:
      IDENT
    | IDENT '(' expression_list ')'
    ;

/*
 **************************************************
 * The weight clause
 **************************************************
 */

weight_clause:
      %empty
    | '[' IDENT '=' expression ']';

/*
 **************************************************
 * The if clause
 **************************************************
 */

if_clause:
      %empty
    | IF expression
    ;

/*
 **************************************************
 * The in clause
 **************************************************
 */

in_clause:
      %empty
    | IN NUMBER '/' NUMBER
    ;

/*
 **************************************************
 * The using clause
 **************************************************
 */

using_clause:
      %empty
    | USING STRING_LITERAL
    | USING IDENT
    ;

/*
 ******************************
 * The "special" Stata commands
 ******************************
 */

merge_cmd:
    MERGE
    ;

%%

